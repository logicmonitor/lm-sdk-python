# coding: utf-8

"""
    LogicMonitor REST API

    LogicMonitor is a SaaS-based performance monitoring platform that provides full visibility into complex, hybrid infrastructures, offering granular performance monitoring and actionable data and insights. logicmonitor_sdk enables you to manage your LogicMonitor account programmatically. <br> <br> Note: <ul> <li> For Python SDKs, the REQUEST parameters can contain camelCase or an underscore. </li> <li> Both underscore and camelCase are supported if parameters are encapsulated within the body. </li> <li> Only camelCase is supported if parameters are encapsulated within the body and also if the user is passing raw JSON as REQUEST parameter. However, the RESPONSE parameters always contain an underscore. For example, you can use testLocation or test_location in the REQUEST parameter. But the RESPONSE parameter will always be test_location. </li> <li> The fields parameter only supports camelCase. </li> </ul>  # noqa: E501

    OpenAPI spec version: 3.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from logicmonitor_sdk.api_client import ApiClient


class LMApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def ack_alert_by_id(self, body, id, **kwargs):  # noqa: E501
        """ack alert by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ack_alert_by_id(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertAck body: (required)
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ack_alert_by_id_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.ack_alert_by_id_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def ack_alert_by_id_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """ack alert by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ack_alert_by_id_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertAck body: (required)
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ack_alert_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `ack_alert_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `ack_alert_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts/{id}/ack', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ack_collector_down_alert_by_id(self, id, body, **kwargs):  # noqa: E501
        """ack collector down alert  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ack_collector_down_alert_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AckCollectorDown body: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ack_collector_down_alert_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.ack_collector_down_alert_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def ack_collector_down_alert_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """ack collector down alert  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ack_collector_down_alert_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AckCollectorDown body: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ack_collector_down_alert_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `ack_collector_down_alert_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `ack_collector_down_alert_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}/ackdown', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_access_group(self, **kwargs):  # noqa: E501
        """Create a access group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_access_group(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessGroup body:
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_access_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_access_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_access_group_with_http_info(self, **kwargs):  # noqa: E501
        """Create a access group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_access_group_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessGroup body:
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_access_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_admin(self, body, **kwargs):  # noqa: E501
        """add user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_admin(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Admin body: (required)
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_admin_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_admin_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_admin_with_http_info(self, body, **kwargs):  # noqa: E501
        """add user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_admin_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Admin body: (required)
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_admin" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_admin`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Admin'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_alert_note_by_id(self, body, id, **kwargs):  # noqa: E501
        """add alert note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_alert_note_by_id(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertAck body: (required)
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_alert_note_by_id_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_alert_note_by_id_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def add_alert_note_by_id_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """add alert note  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_alert_note_by_id_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertAck body: (required)
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_alert_note_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_alert_note_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_alert_note_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts/{id}/note', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_alert_rule(self, body, **kwargs):  # noqa: E501
        """add alert rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_alert_rule(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_alert_rule_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_alert_rule_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_alert_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """add alert rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_alert_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_alert_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_alert_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_api_token_by_admin_id(self, admin_id, body, **kwargs):  # noqa: E501
        """add api tokens for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_api_token_by_admin_id(admin_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param APIToken body: (required)
        :param str type:
        :return: APIToken
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_api_token_by_admin_id_with_http_info(admin_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_api_token_by_admin_id_with_http_info(admin_id, body, **kwargs)  # noqa: E501
            return data

    def add_api_token_by_admin_id_with_http_info(self, admin_id, body, **kwargs):  # noqa: E501
        """add api tokens for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_api_token_by_admin_id_with_http_info(admin_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param APIToken body: (required)
        :param str type:
        :return: APIToken
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['admin_id', 'body', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_api_token_by_admin_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'admin_id' is set
        if ('admin_id' not in params or
                params['admin_id'] is None):
            raise ValueError("Missing the required parameter `admin_id` when calling `add_api_token_by_admin_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_api_token_by_admin_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'admin_id' in params:
            path_params['adminId'] = params['admin_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'APIToken'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{adminId}/apitokens', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_applies_to_function(self, **kwargs):  # noqa: E501
        """add applies to function  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_applies_to_function(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AppliesToFunction body:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_applies_to_function_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_applies_to_function_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_applies_to_function_with_http_info(self, **kwargs):  # noqa: E501
        """add applies to function  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_applies_to_function_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AppliesToFunction body:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_applies_to_function" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_collector(self, body, **kwargs):  # noqa: E501
        """add collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_collector(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Collector body: (required)
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_collector_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_collector_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_collector_with_http_info(self, body, **kwargs):  # noqa: E501
        """add collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_collector_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Collector body: (required)
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_collector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_collector`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Collector'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_collector_group(self, body, **kwargs):  # noqa: E501
        """add collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_collector_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CollectorGroup body: (required)
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_collector_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_collector_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_collector_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_collector_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CollectorGroup body: (required)
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_collector_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_collector_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_config_source(self, **kwargs):  # noqa: E501
        """add config source  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_config_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigSource body:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_config_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_config_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_config_source_with_http_info(self, **kwargs):  # noqa: E501
        """add config source  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_config_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigSource body:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_config_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dashboard(self, body, **kwargs):  # noqa: E501
        """add dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Dashboard body: (required)
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_dashboard_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dashboard_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_dashboard_with_http_info(self, body, **kwargs):  # noqa: E501
        """add dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Dashboard body: (required)
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Dashboard'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dashboard_group(self, body, **kwargs):  # noqa: E501
        """add dashboard group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_dashboard_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dashboard_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_dashboard_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add dashboard group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dashboard_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_dashboard_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dashboard_group_asynchronously(self, id, **kwargs):  # noqa: E501
        """add dashboard group asynchronously  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_group_asynchronously(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body:
        :param bool recursive:
        :return: RestDashboardGroupAsyncCloneResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_dashboard_group_asynchronously_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dashboard_group_asynchronously_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def add_dashboard_group_asynchronously_with_http_info(self, id, **kwargs):  # noqa: E501
        """add dashboard group asynchronously  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_group_asynchronously_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body:
        :param bool recursive:
        :return: RestDashboardGroupAsyncCloneResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'recursive']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dashboard_group_asynchronously" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_dashboard_group_asynchronously`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestDashboardGroupAsyncCloneResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}/asyncclone', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_datasource_by_id(self, **kwargs):  # noqa: E501
        """add datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_datasource_by_id(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DataSource body:
        :param bool create_graph:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_datasource_by_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_datasource_by_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_datasource_by_id_with_http_info(self, **kwargs):  # noqa: E501
        """add datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_datasource_by_id_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DataSource body:
        :param bool create_graph:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'create_graph']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'create_graph' in params:
            query_params.append(('createGraph', params['create_graph']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device(self, body, **kwargs):  # noqa: E501
        """add a new device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Device body: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param bool add_from_wizard:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_device_with_http_info(self, body, **kwargs):  # noqa: E501
        """add a new device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Device body: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param bool add_from_wizard:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'start', 'end', 'netflow_filter', 'add_from_wizard']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'add_from_wizard' in params:
            query_params.append(('addFromWizard', params['add_from_wizard']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Device'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_datasource_instance(self, device_id, hds_id, body, **kwargs):  # noqa: E501
        """add device instance   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_datasource_instance(device_id, hds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param DeviceDataSourceInstance body: (required)
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_datasource_instance_with_http_info(device_id, hds_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_datasource_instance_with_http_info(device_id, hds_id, body, **kwargs)  # noqa: E501
            return data

    def add_device_datasource_instance_with_http_info(self, device_id, hds_id, body, **kwargs):  # noqa: E501
        """add device instance   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_datasource_instance_with_http_info(device_id, hds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param DeviceDataSourceInstance body: (required)
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_datasource_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `add_device_datasource_instance`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `add_device_datasource_instance`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_datasource_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstance'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_datasource_instance_group(self, device_id, device_ds_id, body, **kwargs):  # noqa: E501
        """add device datasource instance group   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_datasource_instance_group(device_id, device_ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_datasource_instance_group_with_http_info(device_id, device_ds_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_datasource_instance_group_with_http_info(device_id, device_ds_id, body, **kwargs)  # noqa: E501
            return data

    def add_device_datasource_instance_group_with_http_info(self, device_id, device_ds_id, body, **kwargs):  # noqa: E501
        """add device datasource instance group   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_datasource_instance_group_with_http_info(device_id, device_ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'device_ds_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_datasource_instance_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `add_device_datasource_instance_group`")  # noqa: E501
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `add_device_datasource_instance_group`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_datasource_instance_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_group(self, body, **kwargs):  # noqa: E501
        """add device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceGroup body: (required)
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_device_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceGroup body: (required)
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_group_property(self, gid, body, **kwargs):  # noqa: E501
        """add device group property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group_property(gid, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_group_property_with_http_info(gid, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_group_property_with_http_info(gid, body, **kwargs)  # noqa: E501
            return data

    def add_device_group_property_with_http_info(self, gid, body, **kwargs):  # noqa: E501
        """add device group property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group_property_with_http_info(gid, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_group_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `add_device_group_property`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_group_property`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_property(self, device_id, body, **kwargs):  # noqa: E501
        """add device property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_property(device_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_property_with_http_info(device_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_property_with_http_info(device_id, body, **kwargs)  # noqa: E501
            return data

    def add_device_property_with_http_info(self, device_id, body, **kwargs):  # noqa: E501
        """add device property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_property_with_http_info(device_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `add_device_property`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_property`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_escalation_chain(self, body, **kwargs):  # noqa: E501
        """add escalation chain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_escalation_chain(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_escalation_chain_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_escalation_chain_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_escalation_chain_with_http_info(self, body, **kwargs):  # noqa: E501
        """add escalation chain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_escalation_chain_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_escalation_chain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_escalation_chain`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalatingChain'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_event_source(self, **kwargs):  # noqa: E501
        """add eventSource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_event_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EventSource body:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_event_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_event_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_event_source_with_http_info(self, **kwargs):  # noqa: E501
        """add eventSource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_event_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EventSource body:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_event_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_job_monitor(self, **kwargs):  # noqa: E501
        """Add JobMonitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_job_monitor(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchJob body:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_job_monitor_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_job_monitor_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_job_monitor_with_http_info(self, **kwargs):  # noqa: E501
        """Add JobMonitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_job_monitor_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchJob body:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_job_monitor" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_log_source(self, **kwargs):  # noqa: E501
        """add log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_log_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogSource body:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_log_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_log_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_log_source_with_http_info(self, **kwargs):  # noqa: E501
        """add log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_log_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogSource body:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_log_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_netscan(self, **kwargs):  # noqa: E501
        """add a new netscan  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_netscan(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Netscan body:
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_netscan_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_netscan_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_netscan_with_http_info(self, **kwargs):  # noqa: E501
        """add a new netscan  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_netscan_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Netscan body:
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_netscan" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Netscan'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_oid(self, **kwargs):  # noqa: E501
        """add a new OID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_oid(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_oid_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_oid_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_oid_with_http_info(self, **kwargs):  # noqa: E501
        """add a new OID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_oid_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_oid" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_ops_note(self, body, **kwargs):  # noqa: E501
        """add opsnote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ops_note(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OpsNote body: (required)
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_ops_note_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_ops_note_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_ops_note_with_http_info(self, body, **kwargs):  # noqa: E501
        """add opsnote  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ops_note_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OpsNote body: (required)
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ops_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_ops_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OpsNote'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/opsnotes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_property_rule(self, **kwargs):  # noqa: E501
        """add a new property rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_property_rule(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PropertyRule body:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_property_rule_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_property_rule_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_property_rule_with_http_info(self, **kwargs):  # noqa: E501
        """add a new property rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_property_rule_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PropertyRule body:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_property_rule" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_recipient_group(self, body, **kwargs):  # noqa: E501
        """add recipient group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_recipient_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_recipient_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_recipient_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_recipient_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add recipient group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_recipient_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_recipient_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_recipient_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_report(self, body, **kwargs):  # noqa: E501
        """add report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_report(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_report_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_report_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_report_with_http_info(self, body, **kwargs):  # noqa: E501
        """add report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_report_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportBase'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_report_group(self, body, **kwargs):  # noqa: E501
        """add report group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_report_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_report_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_report_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_report_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add report group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_report_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_report_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_report_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_role(self, body, **kwargs):  # noqa: E501
        """add role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_role_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_role_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_role_with_http_info(self, body, **kwargs):  # noqa: E501
        """add role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Role'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_sdt(self, body, **kwargs):  # noqa: E501
        """add SDT (Response may contain extra fields depending upon the type of SDT being added)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_sdt(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_sdt_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_sdt_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_sdt_with_http_info(self, body, **kwargs):  # noqa: E501
        """add SDT (Response may contain extra fields depending upon the type of SDT being added)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_sdt_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_sdt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_sdt`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDT'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_topology_source(self, **kwargs):  # noqa: E501
        """Add TopologySource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_topology_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopologySource body:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_topology_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_topology_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_topology_source_with_http_info(self, **kwargs):  # noqa: E501
        """Add TopologySource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_topology_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopologySource body:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_topology_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_website(self, body, **kwargs):  # noqa: E501
        """add website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_website(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Website body: (required)
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_website_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_website_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_website_with_http_info(self, body, **kwargs):  # noqa: E501
        """add website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_website_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Website body: (required)
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_website" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_website`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Website'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_website_group(self, body, **kwargs):  # noqa: E501
        """add website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_website_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebsiteGroup body: (required)
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_website_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_website_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_website_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_website_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebsiteGroup body: (required)
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_website_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_website_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_widget(self, body, **kwargs):  # noqa: E501
        """add widget (Based upon widget type the request and response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_widget(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_widget_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_widget_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_widget_with_http_info(self, body, **kwargs):  # noqa: E501
        """add widget (Based upon widget type the request and response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_widget_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_widget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_widget`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Widget'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def collect_device_config_source_config(self, device_id, hds_id, instance_id, **kwargs):  # noqa: E501
        """collect a config for a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collect_device_config_source_config(device_id, hds_id, instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: (required)
        :param int instance_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.collect_device_config_source_config_with_http_info(device_id, hds_id, instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.collect_device_config_source_config_with_http_info(device_id, hds_id, instance_id, **kwargs)  # noqa: E501
            return data

    def collect_device_config_source_config_with_http_info(self, device_id, hds_id, instance_id, **kwargs):  # noqa: E501
        """collect a config for a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collect_device_config_source_config_with_http_info(device_id, hds_id, instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: (required)
        :param int instance_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collect_device_config_source_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `collect_device_config_source_config`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `collect_device_config_source_config`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `collect_device_config_source_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/config/configCollection', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_access_group(self, id, **kwargs):  # noqa: E501
        """Delete access group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_group(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_access_group_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_access_group_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_access_group_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete access group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_group_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_access_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_access_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_admin_by_id(self, id, **kwargs):  # noqa: E501
        """delete user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_admin_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_admin_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_admin_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_admin_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_admin_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_admin_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_admin_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_alert_rule_by_id(self, id, **kwargs):  # noqa: E501
        """delete alert rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_alert_rule_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_alert_rule_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_alert_rule_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_alert_rule_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete alert rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_alert_rule_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_alert_rule_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_alert_rule_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_collector_by_id(self, id, **kwargs):  # noqa: E501
        """delete collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_collector_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_collector_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_collector_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_collector_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_collector_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_collector_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_collector_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_collector_group_by_id(self, id, **kwargs):  # noqa: E501
        """delete collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_collector_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_collector_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_collector_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_collector_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_collector_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_collector_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_collector_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_source_by_id(self, id, **kwargs):  # noqa: E501
        """delete config source by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_config_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete config source by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_config_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dashboard_by_id(self, id, **kwargs):  # noqa: E501
        """delete dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dashboard_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dashboard_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dashboard_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_dashboard_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dashboard_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dashboard_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_dashboard_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dashboard_group_by_id(self, id, **kwargs):  # noqa: E501
        """delete dashboard group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dashboard_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool allow_non_empty_group:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dashboard_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dashboard_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_dashboard_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete dashboard group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dashboard_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool allow_non_empty_group:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'allow_non_empty_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dashboard_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_dashboard_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'allow_non_empty_group' in params:
            query_params.append(('allowNonEmptyGroup', params['allow_non_empty_group']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_datasource_by_id(self, id, **kwargs):  # noqa: E501
        """delete datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datasource_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_datasource_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datasource_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_by_id(self, id, **kwargs):  # noqa: E501
        """delete a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param bool delete_hard:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_device_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param bool delete_hard:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter', 'delete_hard']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_device_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'delete_hard' in params:
            query_params.append(('deleteHard', params['delete_hard']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_datasource_instance_by_id(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """delete a device instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_datasource_instance_by_id(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def delete_device_datasource_instance_by_id_with_http_info(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """delete a device instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_datasource_instance_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `delete_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `delete_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_device_datasource_instance_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_group_by_id(self, id, **kwargs):  # noqa: E501
        """delete device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool delete_children:
        :param bool delete_hard:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_device_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool delete_children:
        :param bool delete_hard:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'delete_children', 'delete_hard']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_device_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'delete_children' in params:
            query_params.append(('deleteChildren', params['delete_children']))  # noqa: E501
        if 'delete_hard' in params:
            query_params.append(('deleteHard', params['delete_hard']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_group_property_by_name(self, gid, name, **kwargs):  # noqa: E501
        """delete device group property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_property_by_name(gid, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_group_property_by_name_with_http_info(gid, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_group_property_by_name_with_http_info(gid, name, **kwargs)  # noqa: E501
            return data

    def delete_device_group_property_by_name_with_http_info(self, gid, name, **kwargs):  # noqa: E501
        """delete device group property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_property_by_name_with_http_info(gid, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_group_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `delete_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_device_group_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_property_by_name(self, device_id, name, **kwargs):  # noqa: E501
        """delete device property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_property_by_name(device_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_property_by_name_with_http_info(device_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_property_by_name_with_http_info(device_id, name, **kwargs)  # noqa: E501
            return data

    def delete_device_property_by_name_with_http_info(self, device_id, name, **kwargs):  # noqa: E501
        """delete device property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_property_by_name_with_http_info(device_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `delete_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_device_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_event_source_by_id(self, id, **kwargs):  # noqa: E501
        """delete eventSource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_event_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_event_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete eventSource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_event_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_event_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_event_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_job_monitor(self, id, **kwargs):  # noqa: E501
        """Delete JobMonitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_monitor(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_job_monitor_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete JobMonitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_monitor_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_job_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_job_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_log_source(self, id, **kwargs):  # noqa: E501
        """delete log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_log_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_log_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_log_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_log_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_log_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_log_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_log_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_oid(self, id, **kwargs):  # noqa: E501
        """delete a OID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_oid(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_oid_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_oid_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_oid_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete a OID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_oid_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_oid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_oid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_property_rule(self, id, **kwargs):  # noqa: E501
        """delete a property rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_property_rule(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_property_rule_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_property_rule_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_property_rule_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete a property rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_property_rule_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_property_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_property_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_report_by_id(self, id, **kwargs):  # noqa: E501
        """delete report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_report_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_report_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_report_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_report_group_by_id(self, id, **kwargs):  # noqa: E501
        """delete report group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_report_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_report_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_report_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_report_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete report group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_report_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_report_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_report_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_role_by_id(self, id, **kwargs):  # noqa: E501
        """delete role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_role_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_role_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_role_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_role_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_role_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_role_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_role_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_sdt_by_id(self, id, **kwargs):  # noqa: E501
        """delete SDT  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sdt_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_sdt_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_sdt_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_sdt_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete SDT  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sdt_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_sdt_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_sdt_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_topology_source(self, id, **kwargs):  # noqa: E501
        """Delete TopologySource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_topology_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_topology_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_topology_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_topology_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete TopologySource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_topology_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_topology_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_topology_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_website_by_id(self, id, **kwargs):  # noqa: E501
        """delete website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_website_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_website_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_website_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_website_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_website_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_website_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_website_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_website_group_by_id(self, id, **kwargs):  # noqa: E501
        """delete website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_website_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int delete_children:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_website_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_website_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_website_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_website_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int delete_children:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'delete_children']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_website_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_website_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'delete_children' in params:
            query_params.append(('deleteChildren', params['delete_children']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_widget_by_id(self, id, **kwargs):  # noqa: E501
        """delete widget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_widget_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_widget_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete widget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_widget_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_widget_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def discover_subscriptions(self, body, **kwargs):  # noqa: E501
        """view subscriptions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.discover_subscriptions(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureSubscriptionsDiscoverV3 body: (required)
        :return: AzureSubscriptionIdPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.discover_subscriptions_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.discover_subscriptions_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def discover_subscriptions_with_http_info(self, body, **kwargs):  # noqa: E501
        """view subscriptions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.discover_subscriptions_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureSubscriptionsDiscoverV3 body: (required)
        :return: AzureSubscriptionIdPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method discover_subscriptions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `discover_subscriptions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AzureSubscriptionIdPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/azure/functions/discoverSubscriptions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def escalated_alert_by_id(self, id, **kwargs):  # noqa: E501
        """escalate alert by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.escalated_alert_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.escalated_alert_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.escalated_alert_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def escalated_alert_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """escalate alert by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.escalated_alert_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method escalated_alert_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `escalated_alert_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts/{id}/escalate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_debug_command(self, **kwargs):  # noqa: E501
        """Execute a Collector debug command  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_debug_command(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Debug body:
        :param int collector_id:
        :return: Debug
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.execute_debug_command_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.execute_debug_command_with_http_info(**kwargs)  # noqa: E501
            return data

    def execute_debug_command_with_http_info(self, **kwargs):  # noqa: E501
        """Execute a Collector debug command  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_debug_command_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Debug body:
        :param int collector_id:
        :return: Debug
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'collector_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_debug_command" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'collector_id' in params:
            query_params.append(('collectorId', params['collector_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Debug'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/debug', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_device_instances_data(self, body, **kwargs):  # noqa: E501
        """fetch device instances data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_device_instances_data(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceInstances body: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str aggregate: the aggregate option
        :return: DeviceInstanceDataPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fetch_device_instances_data_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_device_instances_data_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def fetch_device_instances_data_with_http_info(self, body, **kwargs):  # noqa: E501
        """fetch device instances data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_device_instances_data_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceInstances body: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str aggregate: the aggregate option
        :return: DeviceInstanceDataPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'period', 'start', 'end', 'aggregate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_device_instances_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `fetch_device_instances_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'aggregate' in params:
            query_params.append(('aggregate', params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceInstanceDataPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/instances/datafetch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_report_using_task_id(self, id, task_id, **kwargs):  # noqa: E501
        """get report for task Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_report_using_task_id(id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str task_id: (required)
        :return: GenerateReportResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fetch_report_using_task_id_with_http_info(id, task_id, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_report_using_task_id_with_http_info(id, task_id, **kwargs)  # noqa: E501
            return data

    def fetch_report_using_task_id_with_http_info(self, id, task_id, **kwargs):  # noqa: E501
        """get report for task Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_report_using_task_id_with_http_info(id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str task_id: (required)
        :return: GenerateReportResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'task_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_report_using_task_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `fetch_report_using_task_id`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if ('task_id' not in params or
                params['task_id'] is None):
            raise ValueError("Missing the required parameter `task_id` when calling `fetch_report_using_task_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'task_id' in params:
            path_params['taskId'] = params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GenerateReportResult'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}/tasks/{taskId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_report_by_id(self, id, **kwargs):  # noqa: E501
        """run a report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_report_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param GenerateReportRequest body:
        :return: GenerateReportResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.generate_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def generate_report_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """run a report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_report_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param GenerateReportRequest body:
        :return: GenerateReportResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `generate_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GenerateReportResult'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}/executions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_group_by_id(self, id, **kwargs):  # noqa: E501
        """Get access group by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_access_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get access group by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_access_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_group_list(self, **kwargs):  # noqa: E501
        """Get access group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AccessGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_access_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_access_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get access group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AccessGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_admin_by_id(self, id, **kwargs):  # noqa: E501
        """get user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_admin_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_admin_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_admin_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_admin_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_admin_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Admin'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_admin_list(self, **kwargs):  # noqa: E501
        """get user list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type:
        :param str permission:
        :param str filter_group_string:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AdminPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_admin_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_admin_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_admin_list_with_http_info(self, **kwargs):  # noqa: E501
        """get user list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type:
        :param str permission:
        :param str filter_group_string:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AdminPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'permission', 'filter_group_string', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_admin_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'permission' in params:
            query_params.append(('permission', params['permission']))  # noqa: E501
        if 'filter_group_string' in params:
            query_params.append(('filterGroupString', params['filter_group_string']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AdminPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_by_id(self, id, **kwargs):  # noqa: E501
        """get alert  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :return: Alert
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alert_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get alert  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :return: Alert
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'need_message', 'custom_columns', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_alert_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'need_message' in params:
            query_params.append(('needMessage', params['need_message']))  # noqa: E501
        if 'custom_columns' in params:
            query_params.append(('customColumns', params['custom_columns']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Alert'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_list(self, **kwargs):  # noqa: E501
        """get alert list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertListPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_alert_list_with_http_info(self, **kwargs):  # noqa: E501
        """get alert list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertListPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertListPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_list_by_device_group_id(self, id, **kwargs):  # noqa: E501
        """get device group alerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_by_device_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_list_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_list_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alert_list_by_device_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device group alerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_by_device_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'need_message', 'custom_columns', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_list_by_device_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_alert_list_by_device_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'need_message' in params:
            query_params.append(('needMessage', params['need_message']))  # noqa: E501
        if 'custom_columns' in params:
            query_params.append(('customColumns', params['custom_columns']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_list_by_device_id(self, id, **kwargs):  # noqa: E501
        """get alerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_by_device_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param bool need_message:
        :param str custom_columns:
        :param str bound:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_list_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_list_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alert_list_by_device_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get alerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_by_device_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param bool need_message:
        :param str custom_columns:
        :param str bound:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter', 'need_message', 'custom_columns', 'bound', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_list_by_device_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_alert_list_by_device_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'need_message' in params:
            query_params.append(('needMessage', params['need_message']))  # noqa: E501
        if 'custom_columns' in params:
            query_params.append(('customColumns', params['custom_columns']))  # noqa: E501
        if 'bound' in params:
            query_params.append(('bound', params['bound']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_rule_by_id(self, id, **kwargs):  # noqa: E501
        """get alert rule by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_rule_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_rule_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_rule_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alert_rule_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get alert rule by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_rule_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_rule_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_alert_rule_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_rule_list(self, **kwargs):  # noqa: E501
        """get alert rule list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_rule_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertRulePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_rule_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_rule_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_alert_rule_list_with_http_info(self, **kwargs):  # noqa: E501
        """get alert rule list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_rule_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertRulePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_rule_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRulePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_sdt_list_by_device_id(self, id, **kwargs):  # noqa: E501
        """get SDTs for a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_sdt_list_by_device_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_sdt_list_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_sdt_list_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_all_sdt_list_by_device_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDTs for a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_sdt_list_by_device_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_sdt_list_by_device_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_all_sdt_list_by_device_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_sdt_list_by_website_group_id(self, id, **kwargs):  # noqa: E501
        """get a list of SDTs for a website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_sdt_list_by_website_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_sdt_list_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_sdt_list_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_all_sdt_list_by_website_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get a list of SDTs for a website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_sdt_list_by_website_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_sdt_list_by_website_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_all_sdt_list_by_website_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_api_token_list(self, **kwargs):  # noqa: E501
        """get a list of api tokens across users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_token_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type:
        :param str permission:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ApiTokenPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_api_token_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_api_token_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_api_token_list_with_http_info(self, **kwargs):  # noqa: E501
        """get a list of api tokens across users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_token_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type:
        :param str permission:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ApiTokenPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'permission', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_token_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'permission' in params:
            query_params.append(('permission', params['permission']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ApiTokenPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/apitokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_api_token_list_by_admin_id(self, admin_id, **kwargs):  # noqa: E501
        """get api tokens for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_token_list_by_admin_id(admin_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param str type:
        :param str permission:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ApiTokenPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_api_token_list_by_admin_id_with_http_info(admin_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_api_token_list_by_admin_id_with_http_info(admin_id, **kwargs)  # noqa: E501
            return data

    def get_api_token_list_by_admin_id_with_http_info(self, admin_id, **kwargs):  # noqa: E501
        """get api tokens for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_token_list_by_admin_id_with_http_info(admin_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param str type:
        :param str permission:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ApiTokenPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['admin_id', 'type', 'permission', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_token_list_by_admin_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'admin_id' is set
        if ('admin_id' not in params or
                params['admin_id'] is None):
            raise ValueError("Missing the required parameter `admin_id` when calling `get_api_token_list_by_admin_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'admin_id' in params:
            path_params['adminId'] = params['admin_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'permission' in params:
            query_params.append(('permission', params['permission']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ApiTokenPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{adminId}/apitokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applies_to_function_by_id(self, id, **kwargs):  # noqa: E501
        """get applies to function  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applies_to_function_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_applies_to_function_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_applies_to_function_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_applies_to_function_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get applies to function  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applies_to_function_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applies_to_function_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_applies_to_function_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applies_to_function_list(self, **kwargs):  # noqa: E501
        """get applies to function list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applies_to_function_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RestAppliesToFunctionPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_applies_to_function_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_applies_to_function_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_applies_to_function_list_with_http_info(self, **kwargs):  # noqa: E501
        """get applies to function list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applies_to_function_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RestAppliesToFunctionPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applies_to_function_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestAppliesToFunctionPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_associated_device_list_by_data_source_id(self, id, **kwargs):  # noqa: E501
        """get devices associated with a datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_associated_device_list_by_data_source_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDataSourceAssociatedPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_associated_device_list_by_data_source_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_associated_device_list_by_data_source_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_associated_device_list_by_data_source_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get devices associated with a datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_associated_device_list_by_data_source_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDataSourceAssociatedPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_associated_device_list_by_data_source_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_associated_device_list_by_data_source_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceAssociatedPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_audit_log_list(self, **kwargs):  # noqa: E501
        """Get audit logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_audit_log_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AccessLogPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_audit_log_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_audit_log_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_audit_log_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get audit logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_audit_log_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AccessLogPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_audit_log_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessLogPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accesslogs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aws_account_id(self, **kwargs):  # noqa: E501
        """Get AWS account ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aws_account_id(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsAccountId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aws_account_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_aws_account_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_aws_account_id_with_http_info(self, **kwargs):  # noqa: E501
        """Get AWS account ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aws_account_id_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsAccountId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aws_account_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AwsAccountId'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/aws/accountId', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aws_external_id(self, **kwargs):  # noqa: E501
        """Get AWS external ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aws_external_id(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsExternalId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aws_external_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_aws_external_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_aws_external_id_with_http_info(self, **kwargs):  # noqa: E501
        """Get AWS external ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aws_external_id_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsExternalId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aws_external_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AwsExternalId'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/aws/externalId', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_by_id(self, id, **kwargs):  # noqa: E501
        """get collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_collector_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_collector_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Collector'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_group_by_id(self, id, **kwargs):  # noqa: E501
        """get collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_collector_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_collector_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_group_list(self, **kwargs):  # noqa: E501
        """get collector group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_collector_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get collector group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_installer(self, collector_id, os_and_arch, **kwargs):  # noqa: E501
        """get collector installer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_installer(collector_id, os_and_arch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collector_id: (required)
        :param str os_and_arch: (required)
        :param int collector_version: The version of the installer you'd like to download. This defaults to the latest GD Collector, unless useEA is true
        :param str token:
        :param bool monitor_others:
        :param str collector_size: The size of the Collector you'd like to install. Options are nano, small (requires 2GB memory), medium (requires 4GB memory), large (requires 8GB memory), extra large (requires 16GB memory), double extra large (requires 32GB memory). Requires collector version 22.180 or higher. Defaults to small
        :param bool use_ea: If true, the latest EA Collector version will be used. Defaults to false
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_installer_with_http_info(collector_id, os_and_arch, **kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_installer_with_http_info(collector_id, os_and_arch, **kwargs)  # noqa: E501
            return data

    def get_collector_installer_with_http_info(self, collector_id, os_and_arch, **kwargs):  # noqa: E501
        """get collector installer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_installer_with_http_info(collector_id, os_and_arch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collector_id: (required)
        :param str os_and_arch: (required)
        :param int collector_version: The version of the installer you'd like to download. This defaults to the latest GD Collector, unless useEA is true
        :param str token:
        :param bool monitor_others:
        :param str collector_size: The size of the Collector you'd like to install. Options are nano, small (requires 2GB memory), medium (requires 4GB memory), large (requires 8GB memory), extra large (requires 16GB memory), double extra large (requires 32GB memory). Requires collector version 22.180 or higher. Defaults to small
        :param bool use_ea: If true, the latest EA Collector version will be used. Defaults to false
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collector_id', 'os_and_arch', 'collector_version', 'token', 'monitor_others', 'collector_size', 'use_ea']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_installer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collector_id' is set
        if ('collector_id' not in params or
                params['collector_id'] is None):
            raise ValueError("Missing the required parameter `collector_id` when calling `get_collector_installer`")  # noqa: E501
        # verify the required parameter 'os_and_arch' is set
        if ('os_and_arch' not in params or
                params['os_and_arch'] is None):
            raise ValueError("Missing the required parameter `os_and_arch` when calling `get_collector_installer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collector_id' in params:
            path_params['collectorId'] = params['collector_id']  # noqa: E501
        if 'os_and_arch' in params:
            path_params['osAndArch'] = params['os_and_arch']  # noqa: E501

        query_params = []
        if 'collector_version' in params:
            query_params.append(('collectorVersion', params['collector_version']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'monitor_others' in params:
            query_params.append(('monitorOthers', params['monitor_others']))  # noqa: E501
        if 'collector_size' in params:
            query_params.append(('collectorSize', params['collector_size']))  # noqa: E501
        if 'use_ea' in params:
            query_params.append(('useEA', params['use_ea']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'str'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{collectorId}/installers/{osAndArch}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_list(self, **kwargs):  # noqa: E501
        """get collector list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_collector_list_with_http_info(self, **kwargs):  # noqa: E501
        """get collector list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_version_list(self, **kwargs):  # noqa: E501
        """get collector version list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_version_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorVersionPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_version_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_version_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_collector_version_list_with_http_info(self, **kwargs):  # noqa: E501
        """get collector version list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_version_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorVersionPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_version_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorVersionPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_by_id(self, id, **kwargs):  # noqa: E501
        """get config source by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_config_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get config source by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_config_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_list(self, **kwargs):  # noqa: E501
        """get config source list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ConfigsourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_config_source_list_with_http_info(self, **kwargs):  # noqa: E501
        """get config source list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ConfigsourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigsourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_by_id(self, id, **kwargs):  # noqa: E501
        """get dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool template:
        :param str format:
        :param str fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dashboard_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool template:
        :param str format:
        :param str fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'template', 'format', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_dashboard_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'template' in params:
            query_params.append(('template', params['template']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Dashboard'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_group_by_id(self, id, **kwargs):  # noqa: E501
        """get dashboard group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool template:
        :param str format:
        :param str fields:
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dashboard_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get dashboard group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool template:
        :param str format:
        :param str fields:
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'template', 'format', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_dashboard_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'template' in params:
            query_params.append(('template', params['template']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_group_list(self, **kwargs):  # noqa: E501
        """get dashboard group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DashboardGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_dashboard_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get dashboard group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DashboardGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_list(self, **kwargs):  # noqa: E501
        """get dashboard list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DashboardPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_dashboard_list_with_http_info(self, **kwargs):  # noqa: E501
        """get dashboard list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DashboardPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_data_source_overview_graph_list(self, ds_id, **kwargs):  # noqa: E501
        """get datasource overview graph list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_source_overview_graph_list(ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ds_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DatasourceOverviewGraphPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_data_source_overview_graph_list_with_http_info(ds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_data_source_overview_graph_list_with_http_info(ds_id, **kwargs)  # noqa: E501
            return data

    def get_data_source_overview_graph_list_with_http_info(self, ds_id, **kwargs):  # noqa: E501
        """get datasource overview graph list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_source_overview_graph_list_with_http_info(ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ds_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DatasourceOverviewGraphPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ds_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_data_source_overview_graph_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `get_data_source_overview_graph_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DatasourceOverviewGraphPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{dsId}/ographs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datasource_by_id(self, id, **kwargs):  # noqa: E501
        """get datasource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasource_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :param str fields:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_datasource_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get datasource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasource_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :param str fields:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datasource_list(self, **kwargs):  # noqa: E501
        """get datasource list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasource_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datasource_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_datasource_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_datasource_list_with_http_info(self, **kwargs):  # noqa: E501
        """get datasource list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasource_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datasource_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DatasourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_debug_command_result(self, id, **kwargs):  # noqa: E501
        """Get the result of a Collector debug command using sessionId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_debug_command_result(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int collector_id:
        :return: Debug
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_debug_command_result_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_debug_command_result_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_debug_command_result_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the result of a Collector debug command using sessionId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_debug_command_result_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int collector_id:
        :return: Debug
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'collector_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_debug_command_result" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_debug_command_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'collector_id' in params:
            query_params.append(('collectorId', params['collector_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Debug'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/debug/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_delta_devices(self, delta_id, **kwargs):  # noqa: E501
        """Get delta devices using deltaId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_delta_devices(delta_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delta_id: (required)
        :return: DeviceDeltaPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_delta_devices_with_http_info(delta_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_delta_devices_with_http_info(delta_id, **kwargs)  # noqa: E501
            return data

    def get_delta_devices_with_http_info(self, delta_id, **kwargs):  # noqa: E501
        """Get delta devices using deltaId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_delta_devices_with_http_info(delta_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delta_id: (required)
        :return: DeviceDeltaPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delta_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_delta_devices" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delta_id' is set
        if ('delta_id' not in params or
                params['delta_id'] is None):
            raise ValueError("Missing the required parameter `delta_id` when calling `get_delta_devices`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'delta_id' in params:
            path_params['deltaId'] = params['delta_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDeltaPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/delta/{deltaId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_delta_id_with_devices(self, **kwargs):  # noqa: E501
        """Get filter matched devices with new deltaId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_delta_id_with_devices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delta_id:
        :return: DeviceDeltaPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_delta_id_with_devices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_delta_id_with_devices_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_delta_id_with_devices_with_http_info(self, **kwargs):  # noqa: E501
        """Get filter matched devices with new deltaId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_delta_id_with_devices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delta_id:
        :return: DeviceDeltaPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delta_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_delta_id_with_devices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'delta_id' in params:
            query_params.append(('deltaId', params['delta_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDeltaPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_by_id(self, id, **kwargs):  # noqa: E501
        """get device by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Device'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_config_source_config_list(self, device_id, hds_id, instance_id, **kwargs):  # noqa: E501
        """get detailed config information for the instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_config_source_config_list(device_id, hds_id, instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: (required)
        :param int instance_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstanceConfigPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_config_source_config_list_with_http_info(device_id, hds_id, instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_config_source_config_list_with_http_info(device_id, hds_id, instance_id, **kwargs)  # noqa: E501
            return data

    def get_device_config_source_config_list_with_http_info(self, device_id, hds_id, instance_id, **kwargs):  # noqa: E501
        """get detailed config information for the instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_config_source_config_list_with_http_info(device_id, hds_id, instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: (required)
        :param int instance_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstanceConfigPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_config_source_config_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_config_source_config_list`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_config_source_config_list`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `get_device_config_source_config_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourceInstanceConfigPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_by_id(self, device_id, id, **kwargs):  # noqa: E501
        """get device datasource   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_by_id(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_by_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_by_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_by_id_with_http_info(self, device_id, id, **kwargs):  # noqa: E501
        """get device datasource   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_by_id_with_http_info(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_data_by_id(self, device_id, id, **kwargs):  # noqa: E501
        """get device datasource data   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_data_by_id(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :param str aggregate: the aggregate option
        :return: DeviceDataSourceData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_data_by_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_data_by_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_data_by_id_with_http_info(self, device_id, id, **kwargs):  # noqa: E501
        """get device datasource data   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_data_by_id_with_http_info(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :param str aggregate: the aggregate option
        :return: DeviceDataSourceData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'id', 'period', 'start', 'end', 'datapoints', 'format', 'aggregate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_data_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_data_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_data_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'datapoints' in params:
            query_params.append(('datapoints', params['datapoints']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'aggregate' in params:
            query_params.append(('aggregate', params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceData'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{id}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_alert_setting_list_of_dsi(self, device_id, hds_id, instance_id, **kwargs):  # noqa: E501
        """get a list of alert settings for a device datasource instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_alert_setting_list_of_dsi(device_id, hds_id, instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int size:
        :param int offset:
        :return: DeviceDataSourceInstanceAlertSettingPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_alert_setting_list_of_dsi_with_http_info(device_id, hds_id, instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_alert_setting_list_of_dsi_with_http_info(device_id, hds_id, instance_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_alert_setting_list_of_dsi_with_http_info(self, device_id, hds_id, instance_id, **kwargs):  # noqa: E501
        """get a list of alert settings for a device datasource instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_alert_setting_list_of_dsi_with_http_info(device_id, hds_id, instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int size:
        :param int offset:
        :return: DeviceDataSourceInstanceAlertSettingPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id', 'size', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_alert_setting_list_of_dsi" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_alert_setting_list_of_dsi`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_alert_setting_list_of_dsi`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `get_device_datasource_instance_alert_setting_list_of_dsi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501

        query_params = []
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceAlertSettingPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/alertsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_by_id(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_by_id(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_by_id_with_http_info(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstance'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_data(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_data(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :return: DeviceDataSourceInstanceData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_data_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_data_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_data_with_http_info(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_data_with_http_info(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :return: DeviceDataSourceInstanceData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'period', 'start', 'end', 'datapoints', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_data`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_data`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'datapoints' in params:
            query_params.append(('datapoints', params['datapoints']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceData'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_graph_data(self, device_id, hds_id, id, graph_id, **kwargs):  # noqa: E501
        """get device instance graph data   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_graph_data(device_id, hds_id, id, graph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param int graph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_graph_data_with_http_info(device_id, hds_id, id, graph_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_graph_data_with_http_info(device_id, hds_id, id, graph_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_graph_data_with_http_info(self, device_id, hds_id, id, graph_id, **kwargs):  # noqa: E501
        """get device instance graph data   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_graph_data_with_http_info(device_id, hds_id, id, graph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param int graph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'graph_id', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_graph_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_graph_data`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_graph_data`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_graph_data`")  # noqa: E501
        # verify the required parameter 'graph_id' is set
        if ('graph_id' not in params or
                params['graph_id'] is None):
            raise ValueError("Missing the required parameter `graph_id` when calling `get_device_datasource_instance_graph_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'graph_id' in params:
            path_params['graphId'] = params['graph_id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}/graphs/{graphId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_group_by_id(self, device_id, device_ds_id, id, **kwargs):  # noqa: E501
        """get device datasource instance group   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_by_id(device_id, device_ds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_group_by_id_with_http_info(self, device_id, device_ds_id, id, **kwargs):  # noqa: E501
        """get device datasource instance group   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'device_ds_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `get_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_group_list(self, device_id, device_ds_id, **kwargs):  # noqa: E501
        """get device datasource instance group list   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_list(device_id, device_ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstanceGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_group_list_with_http_info(device_id, device_ds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_group_list_with_http_info(device_id, device_ds_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_group_list_with_http_info(self, device_id, device_ds_id, **kwargs):  # noqa: E501
        """get device datasource instance group list   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_list_with_http_info(device_id, device_ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstanceGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'device_ds_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_group_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_group_list`")  # noqa: E501
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `get_device_datasource_instance_group_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourceInstanceGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_group_overview_graph_data(self, device_id, device_ds_id, dsig_id, ograph_id, **kwargs):  # noqa: E501
        """get device instance group overview graph data   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_overview_graph_data(device_id, device_ds_id, dsig_id, ograph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int dsig_id: (required)
        :param int ograph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_group_overview_graph_data_with_http_info(device_id, device_ds_id, dsig_id, ograph_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_group_overview_graph_data_with_http_info(device_id, device_ds_id, dsig_id, ograph_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_group_overview_graph_data_with_http_info(self, device_id, device_ds_id, dsig_id, ograph_id, **kwargs):  # noqa: E501
        """get device instance group overview graph data   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_overview_graph_data_with_http_info(device_id, device_ds_id, dsig_id, ograph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int dsig_id: (required)
        :param int ograph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'device_ds_id', 'dsig_id', 'ograph_id', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_group_overview_graph_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_group_overview_graph_data`")  # noqa: E501
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `get_device_datasource_instance_group_overview_graph_data`")  # noqa: E501
        # verify the required parameter 'dsig_id' is set
        if ('dsig_id' not in params or
                params['dsig_id'] is None):
            raise ValueError("Missing the required parameter `dsig_id` when calling `get_device_datasource_instance_group_overview_graph_data`")  # noqa: E501
        # verify the required parameter 'ograph_id' is set
        if ('ograph_id' not in params or
                params['ograph_id'] is None):
            raise ValueError("Missing the required parameter `ograph_id` when calling `get_device_datasource_instance_group_overview_graph_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'dsig_id' in params:
            path_params['dsigId'] = params['dsig_id']  # noqa: E501
        if 'ograph_id' in params:
            path_params['ographId'] = params['ograph_id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{dsigId}/graphs/{ographId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_list(self, device_id, hds_id, **kwargs):  # noqa: E501
        """get device instance list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_list(device_id, hds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstancePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_list_with_http_info(device_id, hds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_list_with_http_info(device_id, hds_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_list_with_http_info(self, device_id, hds_id, **kwargs):  # noqa: E501
        """get device instance list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_list_with_http_info(device_id, hds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstancePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_list`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourceInstancePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_sdt_history(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance SDT history  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_sdt_history(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_sdt_history_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_sdt_history_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_sdt_history_with_http_info(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance SDT history  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_sdt_history_with_http_info(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_sdt_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_sdt_history`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_sdt_history`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_sdt_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_list(self, device_id, **kwargs):  # noqa: E501
        """get device datasource list   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_list(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_list_with_http_info(device_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_list_with_http_info(device_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_list_with_http_info(self, device_id, **kwargs):  # noqa: E501
        """get device datasource list   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_list_with_http_info(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_by_id(self, id, **kwargs):  # noqa: E501
        """get device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_datasource_alert_setting(self, device_group_id, ds_id, **kwargs):  # noqa: E501
        """get device group datasource alert setting   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_alert_setting(device_group_id, ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param str fields:
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, **kwargs)  # noqa: E501
            return data

    def get_device_group_datasource_alert_setting_with_http_info(self, device_group_id, ds_id, **kwargs):  # noqa: E501
        """get device group datasource alert setting   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param str fields:
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'ds_id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_datasource_alert_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `get_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `get_device_group_datasource_alert_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSourceAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{dsId}/alertsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_datasource_by_id(self, device_group_id, id, **kwargs):  # noqa: E501
        """get device group datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_by_id(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_group_datasource_by_id_with_http_info(self, device_group_id, id, **kwargs):  # noqa: E501
        """get device group datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_by_id_with_http_info(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `get_device_group_datasource_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_group_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_datasource_list(self, device_group_id, **kwargs):  # noqa: E501
        """get device group datasource list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_list(device_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param bool include_disabled_data_source_without_instance:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupDatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_datasource_list_with_http_info(device_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_datasource_list_with_http_info(device_group_id, **kwargs)  # noqa: E501
            return data

    def get_device_group_datasource_list_with_http_info(self, device_group_id, **kwargs):  # noqa: E501
        """get device group datasource list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_list_with_http_info(device_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param bool include_disabled_data_source_without_instance:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupDatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'include_disabled_data_source_without_instance', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_datasource_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `get_device_group_datasource_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501

        query_params = []
        if 'include_disabled_data_source_without_instance' in params:
            query_params.append(('includeDisabledDataSourceWithoutInstance', params['include_disabled_data_source_without_instance']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDatasourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_list(self, **kwargs):  # noqa: E501
        """get device group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_device_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get device group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_property_by_name(self, gid, name, **kwargs):  # noqa: E501
        """get device group property by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_property_by_name(gid, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param str fields:
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_property_by_name_with_http_info(gid, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_property_by_name_with_http_info(gid, name, **kwargs)  # noqa: E501
            return data

    def get_device_group_property_by_name_with_http_info(self, gid, name, **kwargs):  # noqa: E501
        """get device group property by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_property_by_name_with_http_info(gid, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param str fields:
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'name', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `get_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_device_group_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_property_list(self, gid, **kwargs):  # noqa: E501
        """get device group properties  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_property_list(gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_property_list_with_http_info(gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_property_list_with_http_info(gid, **kwargs)  # noqa: E501
            return data

    def get_device_group_property_list_with_http_info(self, gid, **kwargs):  # noqa: E501
        """get device group properties  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_property_list_with_http_info(gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_property_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `get_device_group_property_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_sdt_list(self, id, **kwargs):  # noqa: E501
        """get device group SDTs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_sdt_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_sdt_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_sdt_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_group_sdt_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device group SDTs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_sdt_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_sdt_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_group_sdt_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_instance_graph_data_only_by_instance_id(self, instance_id, graph_id, **kwargs):  # noqa: E501
        """get device instance data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_instance_graph_data_only_by_instance_id(instance_id, graph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int graph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_instance_graph_data_only_by_instance_id_with_http_info(instance_id, graph_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_instance_graph_data_only_by_instance_id_with_http_info(instance_id, graph_id, **kwargs)  # noqa: E501
            return data

    def get_device_instance_graph_data_only_by_instance_id_with_http_info(self, instance_id, graph_id, **kwargs):  # noqa: E501
        """get device instance data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_instance_graph_data_only_by_instance_id_with_http_info(instance_id, graph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int graph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instance_id', 'graph_id', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_instance_graph_data_only_by_instance_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `get_device_instance_graph_data_only_by_instance_id`")  # noqa: E501
        # verify the required parameter 'graph_id' is set
        if ('graph_id' not in params or
                params['graph_id'] is None):
            raise ValueError("Missing the required parameter `graph_id` when calling `get_device_instance_graph_data_only_by_instance_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'graph_id' in params:
            path_params['graphId'] = params['graph_id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devicedatasourceinstances/{instanceId}/graphs/{graphId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_instance_list(self, id, **kwargs):  # noqa: E501
        """get device instance list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_instance_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstancePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_instance_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_instance_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_instance_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device instance list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_instance_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstancePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_instance_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_instance_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourceInstancePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/instances', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_list(self, **kwargs):  # noqa: E501
        """get device list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param bool include_deleted_resources:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_device_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_device_list_with_http_info(self, **kwargs):  # noqa: E501
        """get device list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param bool include_deleted_resources:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'end', 'netflow_filter', 'include_deleted_resources', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'include_deleted_resources' in params:
            query_params.append(('includeDeletedResources', params['include_deleted_resources']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DevicePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_property_by_name(self, device_id, name, **kwargs):  # noqa: E501
        """get device property by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_property_by_name(device_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param str fields:
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_property_by_name_with_http_info(device_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_property_by_name_with_http_info(device_id, name, **kwargs)  # noqa: E501
            return data

    def get_device_property_by_name_with_http_info(self, device_id, name, **kwargs):  # noqa: E501
        """get device property by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_property_by_name_with_http_info(device_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param str fields:
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'name', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_device_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_property_list(self, device_id, **kwargs):  # noqa: E501
        """get device properties  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_property_list(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_property_list_with_http_info(device_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_property_list_with_http_info(device_id, **kwargs)  # noqa: E501
            return data

    def get_device_property_list_with_http_info(self, device_id, **kwargs):  # noqa: E501
        """get device properties  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_property_list_with_http_info(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_property_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_property_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_escalation_chain_by_id(self, id, **kwargs):  # noqa: E501
        """get escalation chain by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_escalation_chain_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_escalation_chain_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_escalation_chain_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_escalation_chain_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get escalation chain by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_escalation_chain_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_escalation_chain_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_escalation_chain_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalatingChain'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_escalation_chain_list(self, **kwargs):  # noqa: E501
        """get escalation chain list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_escalation_chain_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EscalationChainPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_escalation_chain_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_escalation_chain_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_escalation_chain_list_with_http_info(self, **kwargs):  # noqa: E501
        """get escalation chain list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_escalation_chain_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EscalationChainPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_escalation_chain_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalationChainPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_source_by_id(self, id, **kwargs):  # noqa: E501
        """get eventSource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_event_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get eventSource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_event_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_source_list(self, **kwargs):  # noqa: E501
        """get eventSource list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_source_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EventSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_event_source_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_event_source_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_event_source_list_with_http_info(self, **kwargs):  # noqa: E501
        """get eventSource list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_source_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EventSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_source_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_external_api_stats(self, **kwargs):  # noqa: E501
        """get external api stats info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_api_stats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiPerfMetrics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_external_api_stats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_external_api_stats_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_external_api_stats_with_http_info(self, **kwargs):  # noqa: E501
        """get external api stats info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_api_stats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiPerfMetrics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_external_api_stats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ApiPerfMetrics'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/apiStats/externalApis', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_immediate_device_list_by_device_group_id(self, id, **kwargs):  # noqa: E501
        """get immediate devices under group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_immediate_device_list_by_device_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_immediate_device_list_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_immediate_device_list_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_immediate_device_list_by_device_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get immediate devices under group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_immediate_device_list_by_device_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_immediate_device_list_by_device_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_immediate_device_list_by_device_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DevicePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_immediate_website_list_by_website_group_id(self, id, **kwargs):  # noqa: E501
        """get a list of websites for a group (Response may contain extra fields depending upon the type of check { PingCheck | WebCheck} being added)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_immediate_website_list_by_website_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsitePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_immediate_website_list_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_immediate_website_list_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_immediate_website_list_by_website_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get a list of websites for a group (Response may contain extra fields depending upon the type of check { PingCheck | WebCheck} being added)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_immediate_website_list_by_website_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsitePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_immediate_website_list_by_website_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_immediate_website_list_by_website_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsitePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}/websites', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_integration_audit_logs(self, **kwargs):  # noqa: E501
        """get integration audit logs list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_integration_audit_logs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: IntegrationAuditLogPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_integration_audit_logs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_integration_audit_logs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_integration_audit_logs_with_http_info(self, **kwargs):  # noqa: E501
        """get integration audit logs list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_integration_audit_logs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: IntegrationAuditLogPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_integration_audit_logs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'IntegrationAuditLogPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/integrations/auditlogs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_monitor_by_id(self, id, **kwargs):  # noqa: E501
        """Get JobMonitor by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_monitor_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_monitor_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_monitor_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_job_monitor_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get JobMonitor by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_monitor_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_monitor_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_job_monitor_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_monitor_list(self, **kwargs):  # noqa: E501
        """Get JobMonitor List  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_monitor_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: BatchJobPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_monitor_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_job_monitor_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_job_monitor_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get JobMonitor List  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_monitor_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: BatchJobPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_monitor_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJobPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_source_by_id(self, id, **kwargs):  # noqa: E501
        """get log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str format:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_log_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_log_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str format:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_log_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_source_list(self, **kwargs):  # noqa: E501
        """get log source list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_source_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: LogSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_source_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_log_source_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_log_source_list_with_http_info(self, **kwargs):  # noqa: E501
        """get log source list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_source_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: LogSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_source_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metrics_usage(self, **kwargs):  # noqa: E501
        """get metrics usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metrics_usage(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Usage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_metrics_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_metrics_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_metrics_usage_with_http_info(self, **kwargs):  # noqa: E501
        """get metrics usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metrics_usage_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Usage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metrics_usage" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Usage'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/metrics/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netflow_flow_list(self, id, **kwargs):  # noqa: E501
        """get netflow flows  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_flow_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: FlowRecordPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netflow_flow_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_netflow_flow_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_netflow_flow_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """get netflow flows  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_flow_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: FlowRecordPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netflow_flow_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_netflow_flow_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'FlowRecordPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/flows', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netscan_by_id(self, id, **kwargs):  # noqa: E501
        """get netscan by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netscan_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netscan_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_netscan_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_netscan_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get netscan by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netscan_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netscan_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_netscan_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Netscan'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netscan_list(self, **kwargs):  # noqa: E501
        """get netscan list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netscan_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: NetscanPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netscan_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_netscan_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_netscan_list_with_http_info(self, **kwargs):  # noqa: E501
        """get netscan list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netscan_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: NetscanPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netscan_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'NetscanPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_oid_list(self, **kwargs):  # noqa: E501
        """get OID's list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oid_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: OidSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_oid_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_oid_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_oid_list_with_http_info(self, **kwargs):  # noqa: E501
        """get OID's list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oid_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: OidSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_oid_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OidSourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_oidby_id(self, id, **kwargs):  # noqa: E501
        """get OID by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oidby_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_oidby_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_oidby_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_oidby_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get OID by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oidby_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_oidby_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_oidby_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ops_note_list(self, **kwargs):  # noqa: E501
        """get opsnote list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ops_note_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter: Filter the response based on tags, createdBy, happenedOn, monitorObjectGroups, monitorObjectNames, or _all field values
        :return: OpsNotePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ops_note_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_ops_note_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_ops_note_list_with_http_info(self, **kwargs):  # noqa: E501
        """get opsnote list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ops_note_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter: Filter the response based on tags, createdBy, happenedOn, monitorObjectGroups, monitorObjectNames, or _all field values
        :return: OpsNotePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ops_note_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OpsNotePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/opsnotes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_property_rules_by_id(self, id, **kwargs):  # noqa: E501
        """get property rules by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_rules_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_property_rules_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_property_rules_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_property_rules_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get property rules by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_rules_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_property_rules_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_property_rules_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_property_rules_list(self, **kwargs):  # noqa: E501
        """get property rules list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_rules_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyRulePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_property_rules_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_property_rules_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_property_rules_list_with_http_info(self, **kwargs):  # noqa: E501
        """get property rules list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_rules_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyRulePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_property_rules_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRulePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipient_group_by_id(self, id, **kwargs):  # noqa: E501
        """get recipient group by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipient_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipient_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipient_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recipient_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get recipient group by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipient_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipient_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_recipient_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipient_group_list(self, **kwargs):  # noqa: E501
        """get recipient group List  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipient_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RecipientGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipient_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_recipient_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_recipient_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get recipient group List  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipient_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RecipientGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipient_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_by_id(self, id, **kwargs):  # noqa: E501
        """get report by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_report_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get report by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportBase'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_group_by_id(self, id, **kwargs):  # noqa: E501
        """get report group by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_report_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_report_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get report group by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_report_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_group_list(self, **kwargs):  # noqa: E501
        """get report group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ReportGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_report_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_report_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get report group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ReportGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_list(self, **kwargs):  # noqa: E501
        """get report list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ReportPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_report_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_report_list_with_http_info(self, **kwargs):  # noqa: E501
        """get report list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ReportPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role_by_id(self, id, **kwargs):  # noqa: E501
        """get role by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_role_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_role_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_role_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get role by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_role_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Role'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role_list(self, **kwargs):  # noqa: E501
        """get role list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool exclude_admin:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RolePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_role_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_role_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_role_list_with_http_info(self, **kwargs):  # noqa: E501
        """get role list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool exclude_admin:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RolePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exclude_admin', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exclude_admin' in params:
            query_params.append(('excludeAdmin', params['exclude_admin']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RolePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_by_id(self, id, **kwargs):  # noqa: E501
        """get SDT by id (Response may contain extra fields depending upon the type of SDT of given id)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT by id (Response may contain extra fields depending upon the type of SDT of given id)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDT'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_device_data_source_id(self, device_id, id, **kwargs):  # noqa: E501
        """get SDT history for the device dataSource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_data_source_id(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDataSourceSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_device_data_source_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_device_data_source_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_device_data_source_id_with_http_info(self, device_id, id, **kwargs):  # noqa: E501
        """get SDT history for the device dataSource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_data_source_id_with_http_info(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDataSourceSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_device_data_source_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_sdt_history_by_device_data_source_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_device_data_source_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_device_group_id(self, id, **kwargs):  # noqa: E501
        """get SDT history for the group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_device_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT history for the group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_device_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_device_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_device_id(self, id, **kwargs):  # noqa: E501
        """get SDT history for the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_device_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT history for the device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_device_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_device_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_website_id(self, id, **kwargs):  # noqa: E501
        """get SDT history for the website (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_website_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_website_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT history for the website (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_website_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_website_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_website_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_list(self, **kwargs):  # noqa: E501
        """get SDT list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_sdt_list_with_http_info(self, **kwargs):  # noqa: E501
        """get SDT list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_site_monitor_check_point_list(self, **kwargs):  # noqa: E501
        """get website checkpoint list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_site_monitor_check_point_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SiteMonitorCheckPointPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_site_monitor_check_point_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_site_monitor_check_point_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_site_monitor_check_point_list_with_http_info(self, **kwargs):  # noqa: E501
        """get website checkpoint list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_site_monitor_check_point_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SiteMonitorCheckPointPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_site_monitor_check_point_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SiteMonitorCheckPointPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/smcheckpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_top_talkers_graph(self, id, **kwargs):  # noqa: E501
        """get top talkers graph  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_top_talkers_graph(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str format:
        :param str keyword:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_top_talkers_graph_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_top_talkers_graph_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_top_talkers_graph_with_http_info(self, id, **kwargs):  # noqa: E501
        """get top talkers graph  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_top_talkers_graph_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str format:
        :param str keyword:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter', 'format', 'keyword']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_top_talkers_graph" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_top_talkers_graph`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/topTalkersGraph', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_topology_source_by_id(self, id, **kwargs):  # noqa: E501
        """Get TopologySource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topology_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_topology_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_topology_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_topology_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get TopologySource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topology_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topology_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_topology_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_topology_source_list(self, **kwargs):  # noqa: E501
        """Get TopologySource List  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topology_source_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TopologySourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_topology_source_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_topology_source_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_topology_source_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get TopologySource List  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topology_source_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TopologySourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topology_source_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unmonitored_device_list(self, **kwargs):  # noqa: E501
        """get unmonitored device list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unmonitored_device_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: UnmonitoredDevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_unmonitored_device_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_unmonitored_device_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_unmonitored_device_list_with_http_info(self, **kwargs):  # noqa: E501
        """get unmonitored device list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unmonitored_device_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: UnmonitoredDevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unmonitored_device_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'UnmonitoredDevicePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/unmonitoreddevices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_update_reason_list_by_config_source_id(self, id, **kwargs):  # noqa: E501
        """get update history for a configSource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_update_reason_list_by_config_source_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ConfigSourceUpdateReasonsPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_update_reason_list_by_config_source_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_update_reason_list_by_config_source_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_update_reason_list_by_config_source_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get update history for a configSource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_update_reason_list_by_config_source_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ConfigSourceUpdateReasonsPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_update_reason_list_by_config_source_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_update_reason_list_by_config_source_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSourceUpdateReasonsPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}/updatereasons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_update_reason_list_by_data_source_id(self, id, **kwargs):  # noqa: E501
        """get update history for a datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_update_reason_list_by_data_source_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DataSourceUpdateReasonsPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_update_reason_list_by_data_source_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_update_reason_list_by_data_source_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_update_reason_list_by_data_source_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get update history for a datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_update_reason_list_by_data_source_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DataSourceUpdateReasonsPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_update_reason_list_by_data_source_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_update_reason_list_by_data_source_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSourceUpdateReasonsPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}/updatereasons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_alert_list_by_website_id(self, id, **kwargs):  # noqa: E501
        """get alerts for a website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_alert_list_by_website_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_alert_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_alert_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_alert_list_by_website_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get alerts for a website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_alert_list_by_website_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'need_message', 'custom_columns', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_alert_list_by_website_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_alert_list_by_website_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'need_message' in params:
            query_params.append(('needMessage', params['need_message']))  # noqa: E501
        if 'custom_columns' in params:
            query_params.append(('customColumns', params['custom_columns']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_by_id(self, id, **kwargs):  # noqa: E501
        """get website by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get website by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Website'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_checkpoint_data_by_id(self, srv_id, check_id, **kwargs):  # noqa: E501
        """get data for a website checkpoint  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_checkpoint_data_by_id(srv_id, check_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int srv_id: (required)
        :param int check_id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :param str aggregate: the aggregate option
        :return: WebsiteCheckpointRawData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_checkpoint_data_by_id_with_http_info(srv_id, check_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_checkpoint_data_by_id_with_http_info(srv_id, check_id, **kwargs)  # noqa: E501
            return data

    def get_website_checkpoint_data_by_id_with_http_info(self, srv_id, check_id, **kwargs):  # noqa: E501
        """get data for a website checkpoint  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_checkpoint_data_by_id_with_http_info(srv_id, check_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int srv_id: (required)
        :param int check_id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :param str aggregate: the aggregate option
        :return: WebsiteCheckpointRawData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['srv_id', 'check_id', 'period', 'start', 'end', 'datapoints', 'format', 'aggregate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_checkpoint_data_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'srv_id' is set
        if ('srv_id' not in params or
                params['srv_id'] is None):
            raise ValueError("Missing the required parameter `srv_id` when calling `get_website_checkpoint_data_by_id`")  # noqa: E501
        # verify the required parameter 'check_id' is set
        if ('check_id' not in params or
                params['check_id'] is None):
            raise ValueError("Missing the required parameter `check_id` when calling `get_website_checkpoint_data_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'srv_id' in params:
            path_params['srvId'] = params['srv_id']  # noqa: E501
        if 'check_id' in params:
            path_params['checkId'] = params['check_id']  # noqa: E501

        query_params = []
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'datapoints' in params:
            query_params.append(('datapoints', params['datapoints']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'aggregate' in params:
            query_params.append(('aggregate', params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteCheckpointRawData'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{srvId}/checkpoints/{checkId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_data_by_graph_name(self, id, graph_name, **kwargs):  # noqa: E501
        """get website data by graph name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_data_by_graph_name(id, graph_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str graph_name: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_data_by_graph_name_with_http_info(id, graph_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_data_by_graph_name_with_http_info(id, graph_name, **kwargs)  # noqa: E501
            return data

    def get_website_data_by_graph_name_with_http_info(self, id, graph_name, **kwargs):  # noqa: E501
        """get website data by graph name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_data_by_graph_name_with_http_info(id, graph_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str graph_name: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'graph_name', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_data_by_graph_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_data_by_graph_name`")  # noqa: E501
        # verify the required parameter 'graph_name' is set
        if ('graph_name' not in params or
                params['graph_name'] is None):
            raise ValueError("Missing the required parameter `graph_name` when calling `get_website_data_by_graph_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'graph_name' in params:
            path_params['graphName'] = params['graph_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/graphs/{graphName}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_graph_data(self, website_id, checkpoint_id, graph_name, **kwargs):  # noqa: E501
        """get website graph data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_graph_data(website_id, checkpoint_id, graph_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int website_id: (required)
        :param int checkpoint_id: (required)
        :param str graph_name: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_graph_data_with_http_info(website_id, checkpoint_id, graph_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_graph_data_with_http_info(website_id, checkpoint_id, graph_name, **kwargs)  # noqa: E501
            return data

    def get_website_graph_data_with_http_info(self, website_id, checkpoint_id, graph_name, **kwargs):  # noqa: E501
        """get website graph data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_graph_data_with_http_info(website_id, checkpoint_id, graph_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int website_id: (required)
        :param int checkpoint_id: (required)
        :param str graph_name: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['website_id', 'checkpoint_id', 'graph_name', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_graph_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'website_id' is set
        if ('website_id' not in params or
                params['website_id'] is None):
            raise ValueError("Missing the required parameter `website_id` when calling `get_website_graph_data`")  # noqa: E501
        # verify the required parameter 'checkpoint_id' is set
        if ('checkpoint_id' not in params or
                params['checkpoint_id'] is None):
            raise ValueError("Missing the required parameter `checkpoint_id` when calling `get_website_graph_data`")  # noqa: E501
        # verify the required parameter 'graph_name' is set
        if ('graph_name' not in params or
                params['graph_name'] is None):
            raise ValueError("Missing the required parameter `graph_name` when calling `get_website_graph_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'website_id' in params:
            path_params['websiteId'] = params['website_id']  # noqa: E501
        if 'checkpoint_id' in params:
            path_params['checkpointId'] = params['checkpoint_id']  # noqa: E501
        if 'graph_name' in params:
            path_params['graphName'] = params['graph_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{websiteId}/checkpoints/{checkpointId}/graphs/{graphName}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_group_by_id(self, id, **kwargs):  # noqa: E501
        """get website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_group_list(self, **kwargs):  # noqa: E501
        """get website group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_website_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_website_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get website group list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_list(self, **kwargs):  # noqa: E501
        """get website list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collector_ids:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsitePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_website_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_website_list_with_http_info(self, **kwargs):  # noqa: E501
        """get website list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collector_ids:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsitePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collector_ids', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'collector_ids' in params:
            query_params.append(('collectorIds', params['collector_ids']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsitePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_property_list_by_website_id(self, id, **kwargs):  # noqa: E501
        """get a list of properties for a website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_property_list_by_website_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_property_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_property_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_property_list_by_website_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get a list of properties for a website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_property_list_by_website_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_property_list_by_website_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_property_list_by_website_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_sdt_list_by_website_id(self, id, **kwargs):  # noqa: E501
        """get a list of SDTs for a website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_sdt_list_by_website_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_sdt_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_sdt_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_sdt_list_by_website_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get a list of SDTs for a website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_sdt_list_by_website_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_sdt_list_by_website_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_sdt_list_by_website_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_widget_by_id(self, id, **kwargs):  # noqa: E501
        """get widget by id (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_widget_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get widget by id (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Widget'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_widget_data_by_id(self, id, **kwargs):  # noqa: E501
        """get widget data (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_data_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: WidgetData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_widget_data_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_widget_data_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_widget_data_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get widget data (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_data_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: WidgetData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_data_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_widget_data_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WidgetData'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_widget_list(self, **kwargs):  # noqa: E501
        """get widget list (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WidgetPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_widget_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_widget_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_widget_list_with_http_info(self, **kwargs):  # noqa: E501
        """get widget list (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WidgetPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WidgetPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_widget_list_by_dashboard_id(self, id, **kwargs):  # noqa: E501
        """get widget list by DashboardId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_list_by_dashboard_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WidgetPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_widget_list_by_dashboard_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_widget_list_by_dashboard_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_widget_list_by_dashboard_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get widget list by DashboardId  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_list_by_dashboard_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WidgetPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_list_by_dashboard_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_widget_list_by_dashboard_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WidgetPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}/widgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def map_un_map_module_to_access_group(self, **kwargs):  # noqa: E501
        """Create a mapping of access group & module  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.map_un_map_module_to_access_group(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestMapModuleV3 body:
        :return: RestMapModuleV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.map_un_map_module_to_access_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.map_un_map_module_to_access_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def map_un_map_module_to_access_group_with_http_info(self, **kwargs):  # noqa: E501
        """Create a mapping of access group & module  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.map_un_map_module_to_access_group_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestMapModuleV3 body:
        :return: RestMapModuleV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method map_un_map_module_to_access_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestMapModuleV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/mapunmap/modules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_access_group(self, id, body, **kwargs):  # noqa: E501
        """Update access group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_access_group(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AccessGroup body: (required)
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_access_group_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_access_group_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_access_group_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update access group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_access_group_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AccessGroup body: (required)
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_access_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_access_group`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_access_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_admin_by_id(self, id, body, **kwargs):  # noqa: E501
        """update user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_admin_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Admin body: (required)
        :param bool change_password:
        :param bool validation_only:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_admin_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_admin_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_admin_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_admin_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Admin body: (required)
        :param bool change_password:
        :param bool validation_only:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'change_password', 'validation_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_admin_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_admin_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_admin_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'change_password' in params:
            query_params.append(('changePassword', params['change_password']))  # noqa: E501
        if 'validation_only' in params:
            query_params.append(('validationOnly', params['validation_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Admin'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_alert_rule_by_id(self, id, body, **kwargs):  # noqa: E501
        """update alert rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_alert_rule_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_alert_rule_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_alert_rule_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_alert_rule_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update alert rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_alert_rule_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_alert_rule_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_alert_rule_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_alert_rule_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_applies_to_function(self, id, **kwargs):  # noqa: E501
        """update applies to function  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_applies_to_function(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AppliesToFunction body:
        :param str reason:
        :param bool ignore_reference:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_applies_to_function_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_applies_to_function_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_applies_to_function_with_http_info(self, id, **kwargs):  # noqa: E501
        """update applies to function  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_applies_to_function_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AppliesToFunction body:
        :param str reason:
        :param bool ignore_reference:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason', 'ignore_reference']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_applies_to_function" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_applies_to_function`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'ignore_reference' in params:
            query_params.append(('ignoreReference', params['ignore_reference']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_collector_by_id(self, id, body, **kwargs):  # noqa: E501
        """update collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_collector_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Collector body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_collector_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_collector_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_collector_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_collector_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Collector body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'auto_balance_monitored_devices', 'force_update_failed_over_devices', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_collector_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_collector_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_collector_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'auto_balance_monitored_devices' in params:
            query_params.append(('autoBalanceMonitoredDevices', params['auto_balance_monitored_devices']))  # noqa: E501
        if 'force_update_failed_over_devices' in params:
            query_params.append(('forceUpdateFailedOverDevices', params['force_update_failed_over_devices']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Collector'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_collector_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_collector_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param CollectorGroup body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_collector_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_collector_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_collector_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_collector_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param CollectorGroup body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'auto_balance_monitored_devices', 'force_update_failed_over_devices', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_collector_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_collector_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_collector_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'auto_balance_monitored_devices' in params:
            query_params.append(('autoBalanceMonitoredDevices', params['auto_balance_monitored_devices']))  # noqa: E501
        if 'force_update_failed_over_devices' in params:
            query_params.append(('forceUpdateFailedOverDevices', params['force_update_failed_over_devices']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_source_by_id(self, id, **kwargs):  # noqa: E501
        """update config source by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ConfigSource body:
        :param str reason:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_config_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """update config source by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ConfigSource body:
        :param str reason:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_config_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_dashboard_by_id(self, id, body, **kwargs):  # noqa: E501
        """update dashboard  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_dashboard_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Dashboard body: (required)
        :param bool overwrite_group_fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_dashboard_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_dashboard_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_dashboard_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update dashboard  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_dashboard_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Dashboard body: (required)
        :param bool overwrite_group_fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'overwrite_group_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_dashboard_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_dashboard_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_dashboard_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'overwrite_group_fields' in params:
            query_params.append(('overwriteGroupFields', params['overwrite_group_fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Dashboard'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_dashboard_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update dashboard group  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_dashboard_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_dashboard_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_dashboard_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_dashboard_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update dashboard group  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_dashboard_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_dashboard_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_dashboard_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_dashboard_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_datasource_by_id(self, id, **kwargs):  # noqa: E501
        """update datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_datasource_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DataSource body:
        :param str reason:
        :param bool force_unique_identifier:
        :param str force_restricted_change_key:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_datasource_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """update datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_datasource_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DataSource body:
        :param str reason:
        :param bool force_unique_identifier:
        :param str force_restricted_change_key:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason', 'force_unique_identifier', 'force_restricted_change_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'force_unique_identifier' in params:
            query_params.append(('forceUniqueIdentifier', params['force_unique_identifier']))  # noqa: E501
        if 'force_restricted_change_key' in params:
            query_params.append(('forceRestrictedChangeKey', params['force_restricted_change_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_default_dashboard(self, id, **kwargs):  # noqa: E501
        """update default dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_default_dashboard(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param RestUserCustomizedDataV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_default_dashboard_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_default_dashboard_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_default_dashboard_with_http_info(self, id, **kwargs):  # noqa: E501
        """update default dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_default_dashboard_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param RestUserCustomizedDataV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_default_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_default_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/userdata/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device(self, id, body, **kwargs):  # noqa: E501
        """update a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Device body: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str op_type:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Device body: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str op_type:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'start', 'end', 'netflow_filter', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Device'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_datasource_instance_alert_setting_by_id(self, device_id, hds_id, instance_id, id, body, **kwargs):  # noqa: E501
        """update device instance alert setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_alert_setting_by_id(device_id, hds_id, instance_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceAlertSetting body: (required)
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_datasource_instance_alert_setting_by_id_with_http_info(self, device_id, hds_id, instance_id, id, body, **kwargs):  # noqa: E501
        """update device instance alert setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceAlertSetting body: (required)
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_datasource_instance_alert_setting_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceAlertSetting'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/alertsettings/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_datasource_instance_by_id(self, device_id, hds_id, id, body, **kwargs):  # noqa: E501
        """update device instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_by_id(device_id, hds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param DeviceDataSourceInstance body: (required)
        :param str op_type:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_datasource_instance_by_id_with_http_info(self, device_id, hds_id, id, body, **kwargs):  # noqa: E501
        """update device instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param DeviceDataSourceInstance body: (required)
        :param str op_type:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_datasource_instance_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `patch_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `patch_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_datasource_instance_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstance'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_datasource_instance_group_by_id(self, device_id, device_ds_id, id, body, **kwargs):  # noqa: E501
        """update device datasource instance group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_group_by_id(device_id, device_ds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_datasource_instance_group_by_id_with_http_info(self, device_id, device_ds_id, id, body, **kwargs):  # noqa: E501
        """update device datasource instance group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'device_ds_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_datasource_instance_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `patch_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `patch_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_datasource_instance_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeviceGroup body: (required)
        :param str op_type:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeviceGroup body: (required)
        :param str op_type:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_datasource_alert_setting(self, device_group_id, ds_id, body, **kwargs):  # noqa: E501
        """update device group datasource alert setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_datasource_alert_setting(device_group_id, ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param DeviceGroupDataSourceAlertConfig body: (required)
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_group_datasource_alert_setting_with_http_info(self, device_group_id, ds_id, body, **kwargs):  # noqa: E501
        """update device group datasource alert setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param DeviceGroupDataSourceAlertConfig body: (required)
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'ds_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_datasource_alert_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `patch_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `patch_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_group_datasource_alert_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSourceAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{dsId}/alertsettings', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_datasource_by_id(self, device_group_id, id, **kwargs):  # noqa: E501
        """update device group datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_datasource_by_id(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceGroupDataSource body:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
            return data

    def patch_device_group_datasource_by_id_with_http_info(self, device_group_id, id, **kwargs):  # noqa: E501
        """update device group datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_datasource_by_id_with_http_info(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceGroupDataSource body:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `patch_device_group_datasource_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_group_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_property_by_name(self, gid, name, body, **kwargs):  # noqa: E501
        """update device group property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_property_by_name(gid, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_property_by_name_with_http_info(gid, name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_property_by_name_with_http_info(gid, name, body, **kwargs)  # noqa: E501
            return data

    def patch_device_group_property_by_name_with_http_info(self, gid, name, body, **kwargs):  # noqa: E501
        """update device group property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_property_by_name_with_http_info(gid, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `patch_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_group_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_property_by_name(self, device_id, name, body, **kwargs):  # noqa: E501
        """update device property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_property_by_name(device_id, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_property_by_name_with_http_info(device_id, name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_property_by_name_with_http_info(device_id, name, body, **kwargs)  # noqa: E501
            return data

    def patch_device_property_by_name_with_http_info(self, device_id, name, body, **kwargs):  # noqa: E501
        """update device property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_property_by_name_with_http_info(device_id, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `patch_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_escalation_chain_by_id(self, id, body, **kwargs):  # noqa: E501
        """update escalation chain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_escalation_chain_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_escalation_chain_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_escalation_chain_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_escalation_chain_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update escalation chain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_escalation_chain_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_escalation_chain_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_escalation_chain_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_escalation_chain_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalatingChain'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_event_source_by_id(self, id, **kwargs):  # noqa: E501
        """update eventSource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_event_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EventSource body:
        :param str reason:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_event_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """update eventSource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_event_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EventSource body:
        :param str reason:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_event_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_event_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_job_monitor(self, id, **kwargs):  # noqa: E501
        """Update JobMonitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_job_monitor(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param BatchJob body:
        :param str reason:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_job_monitor_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update JobMonitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_job_monitor_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param BatchJob body:
        :param str reason:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_job_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_job_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_log_source(self, id, **kwargs):  # noqa: E501
        """update log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_log_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param JSONObject body:
        :param str reason:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_log_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_log_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_log_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """update log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_log_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param JSONObject body:
        :param str reason:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_log_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_log_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_oid(self, id, **kwargs):  # noqa: E501
        """update a OID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_oid(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_oid_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_oid_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_oid_with_http_info(self, id, **kwargs):  # noqa: E501
        """update a OID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_oid_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_oid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_oid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_property_rule(self, id, **kwargs):  # noqa: E501
        """update a property rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_property_rule(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param PropertyRule body:
        :param str reason:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_property_rule_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_property_rule_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_property_rule_with_http_info(self, id, **kwargs):  # noqa: E501
        """update a property rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_property_rule_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param PropertyRule body:
        :param str reason:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_property_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_property_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_recipient_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update recipient group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_recipient_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_recipient_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_recipient_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_recipient_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update recipient group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_recipient_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_recipient_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_recipient_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_recipient_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_report_by_id(self, id, body, **kwargs):  # noqa: E501
        """update report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_report_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_report_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_report_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_report_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_report_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_report_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportBase'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_report_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update report group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_report_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_report_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_report_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_report_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update report group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_report_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_report_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_report_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_report_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_role_by_id(self, id, body, **kwargs):  # noqa: E501
        """update role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_role_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_role_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_role_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_role_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_role_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_role_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_role_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_role_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Role'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_sdt_by_id(self, id, body, **kwargs):  # noqa: E501
        """update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_sdt_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_sdt_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_sdt_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_sdt_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_sdt_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_sdt_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_sdt_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_sdt_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDT'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_topology_source(self, id, **kwargs):  # noqa: E501
        """Update TopologySource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_topology_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param TopologySource body:
        :param str reason:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_topology_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_topology_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_topology_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update TopologySource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_topology_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param TopologySource body:
        :param str reason:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_topology_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_topology_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_website_by_id(self, id, body, **kwargs):  # noqa: E501
        """update website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_website_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Website body: (required)
        :param str op_type:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_website_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_website_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_website_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_website_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Website body: (required)
        :param str op_type:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_website_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_website_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_website_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Website'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_website_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_website_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param WebsiteGroup body: (required)
        :param str op_type:
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_website_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_website_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_website_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_website_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param WebsiteGroup body: (required)
        :param str op_type:
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_website_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_website_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_website_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_widget_by_id(self, id, body, **kwargs):  # noqa: E501
        """update widget (Based upon widget type the request and response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_widget_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_widget_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_widget_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_widget_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update widget (Based upon widget type the request and response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_widget_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_widget_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_widget_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Widget'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schedule_auto_discovery_by_device_id(self, id, **kwargs):  # noqa: E501
        """schedule active discovery for a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schedule_auto_discovery_by_device_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.schedule_auto_discovery_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.schedule_auto_discovery_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def schedule_auto_discovery_by_device_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """schedule active discovery for a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schedule_auto_discovery_by_device_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'start', 'end', 'netflow_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_auto_discovery_by_device_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `schedule_auto_discovery_by_device_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/scheduleAutoDiscovery', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_aws_account(self, body, **kwargs):  # noqa: E501
        """test AWS account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_aws_account(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAwsAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_aws_account_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.test_aws_account_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def test_aws_account_with_http_info(self, body, **kwargs):  # noqa: E501
        """test AWS account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_aws_account_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAwsAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_aws_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `test_aws_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudOkPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/aws/functions/testAccount', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_azure_account(self, body, **kwargs):  # noqa: E501
        """test Azure account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_azure_account(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_azure_account_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.test_azure_account_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def test_azure_account_with_http_info(self, body, **kwargs):  # noqa: E501
        """test Azure account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_azure_account_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_azure_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `test_azure_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudOkPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/azure/functions/testAccount', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_gcp_account(self, body, **kwargs):  # noqa: E501
        """test GCP account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_gcp_account(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestGcpAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_gcp_account_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.test_gcp_account_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def test_gcp_account_with_http_info(self, body, **kwargs):  # noqa: E501
        """test GCP account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_gcp_account_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestGcpAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_gcp_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `test_gcp_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudOkPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/gcp/functions/testAccount', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_saa_s_account(self, body, **kwargs):  # noqa: E501
        """test SaaS account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_saa_s_account(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestSaaSAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_saa_s_account_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.test_saa_s_account_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def test_saa_s_account_with_http_info(self, body, **kwargs):  # noqa: E501
        """test SaaS account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_saa_s_account_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestSaaSAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_saa_s_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `test_saa_s_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudOkPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/saas/functions/testAccount', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_access_group(self, id, body, **kwargs):  # noqa: E501
        """Update access group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_group(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AccessGroup body: (required)
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_access_group_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_access_group_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_access_group_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update access group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_group_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AccessGroup body: (required)
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_access_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_access_group`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_access_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_admin_by_id(self, id, body, **kwargs):  # noqa: E501
        """update user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_admin_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Admin body: (required)
        :param bool change_password:
        :param bool validation_only:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_admin_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_admin_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_admin_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_admin_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Admin body: (required)
        :param bool change_password:
        :param bool validation_only:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'change_password', 'validation_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_admin_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_admin_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_admin_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'change_password' in params:
            query_params.append(('changePassword', params['change_password']))  # noqa: E501
        if 'validation_only' in params:
            query_params.append(('validationOnly', params['validation_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Admin'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_alert_rule_by_id(self, id, body, **kwargs):  # noqa: E501
        """update alert rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alert_rule_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_alert_rule_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_alert_rule_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_alert_rule_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update alert rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alert_rule_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_alert_rule_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_alert_rule_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_alert_rule_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_applies_to_function(self, id, **kwargs):  # noqa: E501
        """update applies to function  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_applies_to_function(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AppliesToFunction body:
        :param str reason:
        :param bool ignore_reference:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_applies_to_function_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_applies_to_function_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_applies_to_function_with_http_info(self, id, **kwargs):  # noqa: E501
        """update applies to function  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_applies_to_function_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AppliesToFunction body:
        :param str reason:
        :param bool ignore_reference:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason', 'ignore_reference']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_applies_to_function" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_applies_to_function`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'ignore_reference' in params:
            query_params.append(('ignoreReference', params['ignore_reference']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_collector_by_id(self, id, body, **kwargs):  # noqa: E501
        """update collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_collector_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Collector body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_collector_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_collector_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_collector_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update collector  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_collector_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Collector body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'auto_balance_monitored_devices', 'force_update_failed_over_devices', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_collector_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_collector_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_collector_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'auto_balance_monitored_devices' in params:
            query_params.append(('autoBalanceMonitoredDevices', params['auto_balance_monitored_devices']))  # noqa: E501
        if 'force_update_failed_over_devices' in params:
            query_params.append(('forceUpdateFailedOverDevices', params['force_update_failed_over_devices']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Collector'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_collector_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_collector_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param CollectorGroup body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_collector_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_collector_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_collector_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update collector group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_collector_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param CollectorGroup body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'auto_balance_monitored_devices', 'force_update_failed_over_devices', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_collector_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_collector_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_collector_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'auto_balance_monitored_devices' in params:
            query_params.append(('autoBalanceMonitoredDevices', params['auto_balance_monitored_devices']))  # noqa: E501
        if 'force_update_failed_over_devices' in params:
            query_params.append(('forceUpdateFailedOverDevices', params['force_update_failed_over_devices']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_config_source_by_id(self, id, **kwargs):  # noqa: E501
        """update config source by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_config_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ConfigSource body:
        :param str reason:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_config_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """update config source by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_config_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ConfigSource body:
        :param str reason:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_config_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_config_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_by_id(self, id, body, **kwargs):  # noqa: E501
        """update dashboard  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Dashboard body: (required)
        :param bool overwrite_group_fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dashboard_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_dashboard_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update dashboard  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Dashboard body: (required)
        :param bool overwrite_group_fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'overwrite_group_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_dashboard_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dashboard_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'overwrite_group_fields' in params:
            query_params.append(('overwriteGroupFields', params['overwrite_group_fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Dashboard'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update dashboard group  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dashboard_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_dashboard_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update dashboard group  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_dashboard_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dashboard_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_datasource_by_id(self, id, **kwargs):  # noqa: E501
        """update datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datasource_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DataSource body:
        :param str reason:
        :param bool force_unique_identifier:
        :param str force_restricted_change_key:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_datasource_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """update datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datasource_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DataSource body:
        :param str reason:
        :param bool force_unique_identifier:
        :param str force_restricted_change_key:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason', 'force_unique_identifier', 'force_restricted_change_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'force_unique_identifier' in params:
            query_params.append(('forceUniqueIdentifier', params['force_unique_identifier']))  # noqa: E501
        if 'force_restricted_change_key' in params:
            query_params.append(('forceRestrictedChangeKey', params['force_restricted_change_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_default_dashboard(self, id, **kwargs):  # noqa: E501
        """update default dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_dashboard(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param RestUserCustomizedDataV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_default_dashboard_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_default_dashboard_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_default_dashboard_with_http_info(self, id, **kwargs):  # noqa: E501
        """update default dashboard  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_dashboard_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param RestUserCustomizedDataV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_default_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_default_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/userdata/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device(self, id, body, **kwargs):  # noqa: E501
        """update a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Device body: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str op_type:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_device_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update a device  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Device body: (required)
        :param int start:
        :param int end:
        :param str netflow_filter:
        :param str op_type:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'start', 'end', 'netflow_filter', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Device'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_datasource_instance_alert_setting_by_id(self, device_id, hds_id, instance_id, id, body, **kwargs):  # noqa: E501
        """update device instance alert setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_alert_setting_by_id(device_id, hds_id, instance_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceAlertSetting body: (required)
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, **kwargs)  # noqa: E501
            return data

    def update_device_datasource_instance_alert_setting_by_id_with_http_info(self, device_id, hds_id, instance_id, id, body, **kwargs):  # noqa: E501
        """update device instance alert setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceAlertSetting body: (required)
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_datasource_instance_alert_setting_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceAlertSetting'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/alertsettings/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_datasource_instance_by_id(self, device_id, hds_id, id, body, **kwargs):  # noqa: E501
        """update device instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_by_id(device_id, hds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param DeviceDataSourceInstance body: (required)
        :param str op_type:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, **kwargs)  # noqa: E501
            return data

    def update_device_datasource_instance_by_id_with_http_info(self, device_id, hds_id, id, body, **kwargs):  # noqa: E501
        """update device instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param DeviceDataSourceInstance body: (required)
        :param str op_type:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_datasource_instance_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `update_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_datasource_instance_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstance'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_datasource_instance_group_by_id(self, device_id, device_ds_id, id, body, **kwargs):  # noqa: E501
        """update device datasource instance group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_group_by_id(device_id, device_ds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, body, **kwargs)  # noqa: E501
            return data

    def update_device_datasource_instance_group_by_id_with_http_info(self, device_id, device_ds_id, id, body, **kwargs):  # noqa: E501
        """update device datasource instance group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_group_by_id_with_http_info(device_id, device_ds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'device_ds_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_datasource_instance_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `update_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_datasource_instance_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeviceGroup body: (required)
        :param str op_type:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_device_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update device group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeviceGroup body: (required)
        :param str op_type:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_datasource_alert_setting(self, device_group_id, ds_id, body, **kwargs):  # noqa: E501
        """update device group datasource alert setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_datasource_alert_setting(device_group_id, ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param DeviceGroupDataSourceAlertConfig body: (required)
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, **kwargs)  # noqa: E501
            return data

    def update_device_group_datasource_alert_setting_with_http_info(self, device_group_id, ds_id, body, **kwargs):  # noqa: E501
        """update device group datasource alert setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param DeviceGroupDataSourceAlertConfig body: (required)
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'ds_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_datasource_alert_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `update_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `update_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_group_datasource_alert_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSourceAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{dsId}/alertsettings', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_datasource_by_id(self, device_group_id, id, **kwargs):  # noqa: E501
        """update device group datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_datasource_by_id(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceGroupDataSource body:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
            return data

    def update_device_group_datasource_by_id_with_http_info(self, device_group_id, id, **kwargs):  # noqa: E501
        """update device group datasource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_datasource_by_id_with_http_info(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceGroupDataSource body:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `update_device_group_datasource_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_group_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_property_by_name(self, gid, name, body, **kwargs):  # noqa: E501
        """update device group property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_property_by_name(gid, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_property_by_name_with_http_info(gid, name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_property_by_name_with_http_info(gid, name, body, **kwargs)  # noqa: E501
            return data

    def update_device_group_property_by_name_with_http_info(self, gid, name, body, **kwargs):  # noqa: E501
        """update device group property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_property_by_name_with_http_info(gid, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `update_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_group_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_property_by_name(self, device_id, name, body, **kwargs):  # noqa: E501
        """update device property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_property_by_name(device_id, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_property_by_name_with_http_info(device_id, name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_property_by_name_with_http_info(device_id, name, body, **kwargs)  # noqa: E501
            return data

    def update_device_property_by_name_with_http_info(self, device_id, name, body, **kwargs):  # noqa: E501
        """update device property  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_property_by_name_with_http_info(device_id, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_escalation_chain_by_id(self, id, body, **kwargs):  # noqa: E501
        """update escalation chain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_escalation_chain_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_escalation_chain_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_escalation_chain_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_escalation_chain_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update escalation chain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_escalation_chain_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_escalation_chain_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_escalation_chain_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_escalation_chain_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalatingChain'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_source_by_id(self, id, **kwargs):  # noqa: E501
        """update eventSource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EventSource body:
        :param str reason:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_event_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """update eventSource by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EventSource body:
        :param str reason:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_event_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_instance_group_alert_threshold(self, device_id, device_ds_id, dsig_id, dp_id, **kwargs):  # noqa: E501
        """update instance group alert threshold (Setting the threshold at default group is not allowed)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_instance_group_alert_threshold(device_id, device_ds_id, dsig_id, dp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int dsig_id: (required)
        :param int dp_id: (required)
        :param RestDeviceInstanceGroupAlertConfigV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_instance_group_alert_threshold_with_http_info(device_id, device_ds_id, dsig_id, dp_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_instance_group_alert_threshold_with_http_info(device_id, device_ds_id, dsig_id, dp_id, **kwargs)  # noqa: E501
            return data

    def update_instance_group_alert_threshold_with_http_info(self, device_id, device_ds_id, dsig_id, dp_id, **kwargs):  # noqa: E501
        """update instance group alert threshold (Setting the threshold at default group is not allowed)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_instance_group_alert_threshold_with_http_info(device_id, device_ds_id, dsig_id, dp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int dsig_id: (required)
        :param int dp_id: (required)
        :param RestDeviceInstanceGroupAlertConfigV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'device_ds_id', 'dsig_id', 'dp_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_instance_group_alert_threshold" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_instance_group_alert_threshold`")  # noqa: E501
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `update_instance_group_alert_threshold`")  # noqa: E501
        # verify the required parameter 'dsig_id' is set
        if ('dsig_id' not in params or
                params['dsig_id'] is None):
            raise ValueError("Missing the required parameter `dsig_id` when calling `update_instance_group_alert_threshold`")  # noqa: E501
        # verify the required parameter 'dp_id' is set
        if ('dp_id' not in params or
                params['dp_id'] is None):
            raise ValueError("Missing the required parameter `dp_id` when calling `update_instance_group_alert_threshold`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'dsig_id' in params:
            path_params['dsigId'] = params['dsig_id']  # noqa: E501
        if 'dp_id' in params:
            path_params['dpId'] = params['dp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{dsigId}/datapoints/{dpId}/alertconfig', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_job_monitor(self, id, **kwargs):  # noqa: E501
        """Update JobMonitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_job_monitor(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param BatchJob body:
        :param str reason:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_job_monitor_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update JobMonitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_job_monitor_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param BatchJob body:
        :param str reason:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_job_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_job_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_log_source(self, id, **kwargs):  # noqa: E501
        """update log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_log_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param JSONObject body:
        :param str reason:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_log_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_log_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_log_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """update log source   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_log_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param JSONObject body:
        :param str reason:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_log_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_log_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_oid(self, id, **kwargs):  # noqa: E501
        """update a OID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_oid(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_oid_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_oid_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_oid_with_http_info(self, id, **kwargs):  # noqa: E501
        """update a OID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_oid_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_oid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_oid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_property_rule(self, id, **kwargs):  # noqa: E501
        """update a property rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_property_rule(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param PropertyRule body:
        :param str reason:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_property_rule_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_property_rule_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_property_rule_with_http_info(self, id, **kwargs):  # noqa: E501
        """update a property rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_property_rule_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param PropertyRule body:
        :param str reason:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_property_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_property_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_recipient_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update recipient group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_recipient_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_recipient_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_recipient_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_recipient_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update recipient group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_recipient_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_recipient_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_recipient_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_recipient_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report_by_id(self, id, body, **kwargs):  # noqa: E501
        """update report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_report_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_report_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_report_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update report  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_report_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_report_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportBase'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update report group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_report_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_report_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_report_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update report group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_report_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_report_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_report_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_role_by_id(self, id, body, **kwargs):  # noqa: E501
        """update role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_role_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_role_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_role_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_role_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_role_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_role_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_role_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_role_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Role'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_sdt_by_id(self, id, body, **kwargs):  # noqa: E501
        """update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_sdt_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_sdt_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_sdt_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_sdt_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_sdt_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_sdt_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_sdt_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_sdt_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDT'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_topology_source(self, id, **kwargs):  # noqa: E501
        """Update TopologySource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topology_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param TopologySource body:
        :param str reason:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_topology_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_topology_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_topology_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update TopologySource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topology_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param TopologySource body:
        :param str reason:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_topology_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_topology_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_website_by_id(self, id, body, **kwargs):  # noqa: E501
        """update website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_website_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Website body: (required)
        :param str op_type:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_website_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_website_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_website_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update website  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_website_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Website body: (required)
        :param str op_type:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_website_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_website_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_website_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Website'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_website_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_website_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param WebsiteGroup body: (required)
        :param str op_type:
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_website_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_website_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_website_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update website group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_website_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param WebsiteGroup body: (required)
        :param str op_type:
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_website_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_website_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_website_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_widget_by_id(self, id, body, **kwargs):  # noqa: E501
        """update widget (Based upon widget type the request and response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_widget_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_widget_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_widget_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_widget_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update widget (Based upon widget type the request and response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_widget_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_widget_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_widget_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Widget'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_storage_accounts_permissions(self, body, **kwargs):  # noqa: E501
        """view storage accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_storage_accounts_permissions(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureStorageAccountVerify body: (required)
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.verify_storage_accounts_permissions_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_storage_accounts_permissions_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def verify_storage_accounts_permissions_with_http_info(self, body, **kwargs):  # noqa: E501
        """view storage accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_storage_accounts_permissions_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureStorageAccountVerify body: (required)
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_storage_accounts_permissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `verify_storage_accounts_permissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/azure/functions/verifyStorageAccountsPermissions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
