# coding: utf-8

"""
    LogicMonitor REST API

    LogicMonitor is a SaaS-based performance monitoring platform that provides full visibility into complex, hybrid infrastructures, offering granular performance monitoring and actionable data and insights. logicmonitor_sdk enables you to manage your LogicMonitor account programmatically. <br> <br> Note: <ul> <li> For Python SDKs, the REQUEST parameters can contain camelCase or an underscore. </li> <li> Both underscore and camelCase are supported if parameters are encapsulated within the body. </li> <li> Only camelCase is supported if parameters are encapsulated within the body and also if the user is passing raw JSON as REQUEST parameter. However, the RESPONSE parameters always contain an underscore. For example, you can use testLocation or test_location in the REQUEST parameter. But the RESPONSE parameter will always be test_location. </li> <li> The fields parameter only supports camelCase. </li> </ul>  # noqa: E501

    OpenAPI spec version: 3.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from logicmonitor_sdk.models.report_base import ReportBase  # noqa: F401,E501

class AlertReport(ReportBase):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'active_only': 'bool',
        'sorted_by': 'str',
        'chain': 'str',
        'anomaly': 'str',
        'date_range': 'str',
        'level': 'str',
        'timing': 'str',
        'columns': 'list[DynamicColumn]',
        'data_point': 'str',
        'sdt_filter': 'str',
        'rule': 'str',
        'ack_filter': 'str',
        'sorted_direction': 'str',
        'device_display_name': 'str',
        'summary_only': 'bool',
        'dependency_routing_state': 'str',
        'dependency_role': 'str',
        'data_source_instance_name': 'str',
        'data_source': 'str',
        'group_full_path': 'str',
        'include_preexist': 'object'
    }
    if hasattr(ReportBase, "swagger_types"):
        swagger_types.update(ReportBase.swagger_types)

    attribute_map = {
        'active_only': 'activeOnly',
        'sorted_by': 'sortedBy',
        'chain': 'chain',
        'anomaly': 'anomaly',
        'date_range': 'dateRange',
        'level': 'level',
        'timing': 'timing',
        'columns': 'columns',
        'data_point': 'dataPoint',
        'sdt_filter': 'sdtFilter',
        'rule': 'rule',
        'ack_filter': 'ackFilter',
        'sorted_direction': 'sortedDirection',
        'device_display_name': 'deviceDisplayName',
        'summary_only': 'summaryOnly',
        'dependency_routing_state': 'dependencyRoutingState',
        'dependency_role': 'dependencyRole',
        'data_source_instance_name': 'dataSourceInstanceName',
        'data_source': 'dataSource',
        'group_full_path': 'groupFullPath',
        'include_preexist': 'includePreexist'
    }
    if hasattr(ReportBase, "attribute_map"):
        attribute_map.update(ReportBase.attribute_map)

    def __init__(self, active_only=None, sorted_by=None, chain=None, anomaly=None, date_range=None, level=None, timing=None, columns=None, data_point=None, sdt_filter=None, rule=None, ack_filter=None, sorted_direction=None, device_display_name=None, summary_only=None, dependency_routing_state=None, dependency_role=None, data_source_instance_name=None, data_source=None, group_full_path=None, include_preexist=None, *args, **kwargs):  # noqa: E501
        """AlertReport - a model defined in Swagger"""  # noqa: E501
        self._active_only = None
        self._sorted_by = None
        self._chain = None
        self._anomaly = None
        self._date_range = None
        self._level = None
        self._timing = None
        self._columns = None
        self._data_point = None
        self._sdt_filter = None
        self._rule = None
        self._ack_filter = None
        self._sorted_direction = None
        self._device_display_name = None
        self._summary_only = None
        self._dependency_routing_state = None
        self._dependency_role = None
        self._data_source_instance_name = None
        self._data_source = None
        self._group_full_path = None
        self._include_preexist = None
        self.discriminator = None
        if active_only is not None:
            self.active_only = active_only
        if sorted_by is not None:
            self.sorted_by = sorted_by
        if chain is not None:
            self.chain = chain
        if anomaly is not None:
            self.anomaly = anomaly
        if date_range is not None:
            self.date_range = date_range
        if level is not None:
            self.level = level
        if timing is not None:
            self.timing = timing
        if columns is not None:
            self.columns = columns
        if data_point is not None:
            self.data_point = data_point
        if sdt_filter is not None:
            self.sdt_filter = sdt_filter
        if rule is not None:
            self.rule = rule
        if ack_filter is not None:
            self.ack_filter = ack_filter
        if sorted_direction is not None:
            self.sorted_direction = sorted_direction
        if device_display_name is not None:
            self.device_display_name = device_display_name
        if summary_only is not None:
            self.summary_only = summary_only
        if dependency_routing_state is not None:
            self.dependency_routing_state = dependency_routing_state
        if dependency_role is not None:
            self.dependency_role = dependency_role
        if data_source_instance_name is not None:
            self.data_source_instance_name = data_source_instance_name
        if data_source is not None:
            self.data_source = data_source
        if group_full_path is not None:
            self.group_full_path = group_full_path
        if include_preexist is not None:
            self.include_preexist = include_preexist
        ReportBase.__init__(self, *args, **kwargs)

    @property
    def active_only(self):
        """Gets the active_only of this AlertReport.  # noqa: E501

        true: only alerts that are still alerting (i.e. haven't yet cleared) will be displayed in the report false: active alerts and cleared alerts will both be displayed in the report  # noqa: E501

        :return: The active_only of this AlertReport.  # noqa: E501
        :rtype: bool
        """
        return self._active_only

    @active_only.setter
    def active_only(self, active_only):
        """Sets the active_only of this AlertReport.

        true: only alerts that are still alerting (i.e. haven't yet cleared) will be displayed in the report false: active alerts and cleared alerts will both be displayed in the report  # noqa: E501

        :param active_only: The active_only of this AlertReport.  # noqa: E501
        :type: bool
        """

        self._active_only = active_only

    @property
    def sorted_by(self):
        """Gets the sorted_by of this AlertReport.  # noqa: E501

        count | host | dataPoint | level | startOn | ackedOn. How displayed alerts will be sorted in the report. Note that if summaryOnly is set to true, you are limited to sortedBy= count | host | dataPoint. If summaryOnly is set to false, you cannot set sortedBy = count  # noqa: E501

        :return: The sorted_by of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._sorted_by

    @sorted_by.setter
    def sorted_by(self, sorted_by):
        """Sets the sorted_by of this AlertReport.

        count | host | dataPoint | level | startOn | ackedOn. How displayed alerts will be sorted in the report. Note that if summaryOnly is set to true, you are limited to sortedBy= count | host | dataPoint. If summaryOnly is set to false, you cannot set sortedBy = count  # noqa: E501

        :param sorted_by: The sorted_by of this AlertReport.  # noqa: E501
        :type: str
        """

        self._sorted_by = sorted_by

    @property
    def chain(self):
        """Gets the chain of this AlertReport.  # noqa: E501

        All alerts displayed in the report must have been routed to the Escalation Chains specified in this filter  # noqa: E501

        :return: The chain of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._chain

    @chain.setter
    def chain(self, chain):
        """Sets the chain of this AlertReport.

        All alerts displayed in the report must have been routed to the Escalation Chains specified in this filter  # noqa: E501

        :param chain: The chain of this AlertReport.  # noqa: E501
        :type: str
        """

        self._chain = chain

    @property
    def anomaly(self):
        """Gets the anomaly of this AlertReport.  # noqa: E501

        all|yes|no|yes,no|no,yes all: return all anomaly, non anomaly and unknown anomaly alerts yes: only alerts which has anomaly will be displayed no: only alerts which has no anomaly will be displayed yes,no:  return all anomaly and non anomaly alerts  # noqa: E501

        :return: The anomaly of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._anomaly

    @anomaly.setter
    def anomaly(self, anomaly):
        """Sets the anomaly of this AlertReport.

        all|yes|no|yes,no|no,yes all: return all anomaly, non anomaly and unknown anomaly alerts yes: only alerts which has anomaly will be displayed no: only alerts which has no anomaly will be displayed yes,no:  return all anomaly and non anomaly alerts  # noqa: E501

        :param anomaly: The anomaly of this AlertReport.  # noqa: E501
        :type: str
        """

        self._anomaly = anomaly

    @property
    def date_range(self):
        """Gets the date_range of this AlertReport.  # noqa: E501

        The Time Range configured for the report. Options include: Last 2 hours | Last 24 hours | Last calendar day | Last 7 days | Last 14 days | Last 30 days | Last calendar month | Last 365 days | Any custom date range in this format: YYYY-MM-dd hh:mm TO YYYY-MM-dd hh:mm  # noqa: E501

        :return: The date_range of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._date_range

    @date_range.setter
    def date_range(self, date_range):
        """Sets the date_range of this AlertReport.

        The Time Range configured for the report. Options include: Last 2 hours | Last 24 hours | Last calendar day | Last 7 days | Last 14 days | Last 30 days | Last calendar month | Last 365 days | Any custom date range in this format: YYYY-MM-dd hh:mm TO YYYY-MM-dd hh:mm  # noqa: E501

        :param date_range: The date_range of this AlertReport.  # noqa: E501
        :type: str
        """

        self._date_range = date_range

    @property
    def level(self):
        """Gets the level of this AlertReport.  # noqa: E501

        all | error | critical all: alerts of all severity levels will be displayed if they match the filter criteria error: only error and critical alerts that match the filter criteria will be displayed critical: only critical alerts that match the filter criteria will be displayed  # noqa: E501

        :return: The level of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._level

    @level.setter
    def level(self, level):
        """Sets the level of this AlertReport.

        all | error | critical all: alerts of all severity levels will be displayed if they match the filter criteria error: only error and critical alerts that match the filter criteria will be displayed critical: only critical alerts that match the filter criteria will be displayed  # noqa: E501

        :param level: The level of this AlertReport.  # noqa: E501
        :type: str
        """

        self._level = level

    @property
    def timing(self):
        """Gets the timing of this AlertReport.  # noqa: E501

        overlap | start - Any alerts active during the specified dateRange will be displayed in the report if time=overlap. If time=start, only alerts that started during the specified dateRange will be displayed in the report  # noqa: E501

        :return: The timing of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._timing

    @timing.setter
    def timing(self, timing):
        """Sets the timing of this AlertReport.

        overlap | start - Any alerts active during the specified dateRange will be displayed in the report if time=overlap. If time=start, only alerts that started during the specified dateRange will be displayed in the report  # noqa: E501

        :param timing: The timing of this AlertReport.  # noqa: E501
        :type: str
        """

        self._timing = timing

    @property
    def columns(self):
        """Gets the columns of this AlertReport.  # noqa: E501

        The columns that will be displayed in the report. You should specify the columns in the order in which you'd like them to be displayed. All column names need to be included in this object, but each column should have an associated isHidden field that indicates whether it is displayed or not. NOTE that if summaryOnly is set to true you can only include these columns: Alerts, Group, Device, Instance, Datapoint. If summaryOnly is set to false you can include these columns: Severity, Group, Device, Instance, Datapoint, Thresholds, Value, Began, End, Rule, Chain, Acked, Acked By, Acked On, Notes, In SDT  # noqa: E501

        :return: The columns of this AlertReport.  # noqa: E501
        :rtype: list[DynamicColumn]
        """
        return self._columns

    @columns.setter
    def columns(self, columns):
        """Sets the columns of this AlertReport.

        The columns that will be displayed in the report. You should specify the columns in the order in which you'd like them to be displayed. All column names need to be included in this object, but each column should have an associated isHidden field that indicates whether it is displayed or not. NOTE that if summaryOnly is set to true you can only include these columns: Alerts, Group, Device, Instance, Datapoint. If summaryOnly is set to false you can include these columns: Severity, Group, Device, Instance, Datapoint, Thresholds, Value, Began, End, Rule, Chain, Acked, Acked By, Acked On, Notes, In SDT  # noqa: E501

        :param columns: The columns of this AlertReport.  # noqa: E501
        :type: list[DynamicColumn]
        """

        self._columns = columns

    @property
    def data_point(self):
        """Gets the data_point of this AlertReport.  # noqa: E501

        The group filter used to determine which alerts will appear in the report. Glob expression supported  # noqa: E501

        :return: The data_point of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._data_point

    @data_point.setter
    def data_point(self, data_point):
        """Sets the data_point of this AlertReport.

        The group filter used to determine which alerts will appear in the report. Glob expression supported  # noqa: E501

        :param data_point: The data_point of this AlertReport.  # noqa: E501
        :type: str
        """

        self._data_point = data_point

    @property
    def sdt_filter(self):
        """Gets the sdt_filter of this AlertReport.  # noqa: E501

        all | sdt | nonsdt all: alerts that are in SDT and that aren't in SDT that meet the report criteria will be displayed sdt: only alerts that are in SDT and that meet the report criteria will be displayed nonsdt: only alerts that aren't in SDT and that meet the report criteria will be displayed  # noqa: E501

        :return: The sdt_filter of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._sdt_filter

    @sdt_filter.setter
    def sdt_filter(self, sdt_filter):
        """Sets the sdt_filter of this AlertReport.

        all | sdt | nonsdt all: alerts that are in SDT and that aren't in SDT that meet the report criteria will be displayed sdt: only alerts that are in SDT and that meet the report criteria will be displayed nonsdt: only alerts that aren't in SDT and that meet the report criteria will be displayed  # noqa: E501

        :param sdt_filter: The sdt_filter of this AlertReport.  # noqa: E501
        :type: str
        """

        self._sdt_filter = sdt_filter

    @property
    def rule(self):
        """Gets the rule of this AlertReport.  # noqa: E501

        All alerts displayed in the report must have been routed to the Rules specified in this filter  # noqa: E501

        :return: The rule of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._rule

    @rule.setter
    def rule(self, rule):
        """Sets the rule of this AlertReport.

        All alerts displayed in the report must have been routed to the Rules specified in this filter  # noqa: E501

        :param rule: The rule of this AlertReport.  # noqa: E501
        :type: str
        """

        self._rule = rule

    @property
    def ack_filter(self):
        """Gets the ack_filter of this AlertReport.  # noqa: E501

        all | acked | nonacked all: both acknowledged and non-acknowledged alerts that meet the report criteria will be displayed acked: only acknowledged alerts that meet the report criteria will be displayed nonacked: only non-acknowledged alerts that meet the report criteria will be displayed  # noqa: E501

        :return: The ack_filter of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._ack_filter

    @ack_filter.setter
    def ack_filter(self, ack_filter):
        """Sets the ack_filter of this AlertReport.

        all | acked | nonacked all: both acknowledged and non-acknowledged alerts that meet the report criteria will be displayed acked: only acknowledged alerts that meet the report criteria will be displayed nonacked: only non-acknowledged alerts that meet the report criteria will be displayed  # noqa: E501

        :param ack_filter: The ack_filter of this AlertReport.  # noqa: E501
        :type: str
        """

        self._ack_filter = ack_filter

    @property
    def sorted_direction(self):
        """Gets the sorted_direction of this AlertReport.  # noqa: E501

        asc | desc  # noqa: E501

        :return: The sorted_direction of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._sorted_direction

    @sorted_direction.setter
    def sorted_direction(self, sorted_direction):
        """Sets the sorted_direction of this AlertReport.

        asc | desc  # noqa: E501

        :param sorted_direction: The sorted_direction of this AlertReport.  # noqa: E501
        :type: str
        """

        self._sorted_direction = sorted_direction

    @property
    def device_display_name(self):
        """Gets the device_display_name of this AlertReport.  # noqa: E501

        The device filter used to determine which alerts will appear in the report. Glob expressions supported  # noqa: E501

        :return: The device_display_name of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._device_display_name

    @device_display_name.setter
    def device_display_name(self, device_display_name):
        """Sets the device_display_name of this AlertReport.

        The device filter used to determine which alerts will appear in the report. Glob expressions supported  # noqa: E501

        :param device_display_name: The device_display_name of this AlertReport.  # noqa: E501
        :type: str
        """

        self._device_display_name = device_display_name

    @property
    def summary_only(self):
        """Gets the summary_only of this AlertReport.  # noqa: E501

        true: a column will be added to the report detailing the number of times each alert occurred false: the number of times each alert occurred will not be displayed in the report  # noqa: E501

        :return: The summary_only of this AlertReport.  # noqa: E501
        :rtype: bool
        """
        return self._summary_only

    @summary_only.setter
    def summary_only(self, summary_only):
        """Sets the summary_only of this AlertReport.

        true: a column will be added to the report detailing the number of times each alert occurred false: the number of times each alert occurred will not be displayed in the report  # noqa: E501

        :param summary_only: The summary_only of this AlertReport.  # noqa: E501
        :type: bool
        """

        self._summary_only = summary_only

    @property
    def dependency_routing_state(self):
        """Gets the dependency_routing_state of this AlertReport.  # noqa: E501


        :return: The dependency_routing_state of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._dependency_routing_state

    @dependency_routing_state.setter
    def dependency_routing_state(self, dependency_routing_state):
        """Sets the dependency_routing_state of this AlertReport.


        :param dependency_routing_state: The dependency_routing_state of this AlertReport.  # noqa: E501
        :type: str
        """

        self._dependency_routing_state = dependency_routing_state

    @property
    def dependency_role(self):
        """Gets the dependency_role of this AlertReport.  # noqa: E501


        :return: The dependency_role of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._dependency_role

    @dependency_role.setter
    def dependency_role(self, dependency_role):
        """Sets the dependency_role of this AlertReport.


        :param dependency_role: The dependency_role of this AlertReport.  # noqa: E501
        :type: str
        """

        self._dependency_role = dependency_role

    @property
    def data_source_instance_name(self):
        """Gets the data_source_instance_name of this AlertReport.  # noqa: E501

        The instance filter used to determine which alerts will appear in the report. Glob expressions supported  # noqa: E501

        :return: The data_source_instance_name of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._data_source_instance_name

    @data_source_instance_name.setter
    def data_source_instance_name(self, data_source_instance_name):
        """Sets the data_source_instance_name of this AlertReport.

        The instance filter used to determine which alerts will appear in the report. Glob expressions supported  # noqa: E501

        :param data_source_instance_name: The data_source_instance_name of this AlertReport.  # noqa: E501
        :type: str
        """

        self._data_source_instance_name = data_source_instance_name

    @property
    def data_source(self):
        """Gets the data_source of this AlertReport.  # noqa: E501

        All alerts displayed in the report must have been triggered for the Datasources specified in this filter  # noqa: E501

        :return: The data_source of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._data_source

    @data_source.setter
    def data_source(self, data_source):
        """Sets the data_source of this AlertReport.

        All alerts displayed in the report must have been triggered for the Datasources specified in this filter  # noqa: E501

        :param data_source: The data_source of this AlertReport.  # noqa: E501
        :type: str
        """

        self._data_source = data_source

    @property
    def group_full_path(self):
        """Gets the group_full_path of this AlertReport.  # noqa: E501

        The group filter used to determine which alerts will appear in the report. Glob expressions supported  # noqa: E501

        :return: The group_full_path of this AlertReport.  # noqa: E501
        :rtype: str
        """
        return self._group_full_path

    @group_full_path.setter
    def group_full_path(self, group_full_path):
        """Sets the group_full_path of this AlertReport.

        The group filter used to determine which alerts will appear in the report. Glob expressions supported  # noqa: E501

        :param group_full_path: The group_full_path of this AlertReport.  # noqa: E501
        :type: str
        """

        self._group_full_path = group_full_path

    @property
    def include_preexist(self):
        """Gets the include_preexist of this AlertReport.  # noqa: E501

        true: alerts that started prior to the specified dateRange but that meet all other criteria will be displayed in the report false: only alerts that started during the specified dateRange will be displayed in the report the default value is true  # noqa: E501

        :return: The include_preexist of this AlertReport.  # noqa: E501
        :rtype: object
        """
        return self._include_preexist

    @include_preexist.setter
    def include_preexist(self, include_preexist):
        """Sets the include_preexist of this AlertReport.

        true: alerts that started prior to the specified dateRange but that meet all other criteria will be displayed in the report false: only alerts that started during the specified dateRange will be displayed in the report the default value is true  # noqa: E501

        :param include_preexist: The include_preexist of this AlertReport.  # noqa: E501
        :type: object
        """

        self._include_preexist = include_preexist

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(AlertReport, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, AlertReport):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
